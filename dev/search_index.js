var documenterSearchIndex = {"docs":
[{"location":"generation.html#Signal-Generation","page":"Signal Generation","title":"Signal Generation","text":"","category":"section"},{"location":"generation.html","page":"Signal Generation","title":"Signal Generation","text":"Once the acquisition is triggered, each RedPitaya also starts producing signals on their output channels. Each RedPitaya features six such channels, two of those are the 16-bit DAC channel and four of those are digital pins using PDM, see Connections. The output signals are composed of two parts: parameterized waveforms and repeating arbitrary LUT tables. The latter are called sequences. The resulting signal of the DAC channel can be described as: ","category":"page"},{"location":"generation.html","page":"Signal Generation","title":"Signal Generation","text":"S_i(t) = seq_i(t) + o_i + a_i1w(t f_i1 varphi_i 1) +sum_j=2^4a_ij sin(2pi f_ijt + varphi_i j)","category":"page"},{"location":"generation.html#Waveforms","page":"Signal Generation","title":"Waveforms","text":"","category":"section"},{"location":"generation.html","page":"Signal Generation","title":"Signal Generation","text":"Each of the 16-bit DAC channel can output a compositve waveform with four components. Each component can be parametrized by its amplitude, frequency and phase, which can all be changed via SCPI commands. Furthermore, the first component also offers different waveforms (sine, square, sawtooth), while the remaining components only offer a sine waveform.","category":"page"},{"location":"generation.html","page":"Signal Generation","title":"Signal Generation","text":"Additionally, each channel also has an offset parameter and a calibration offset. The calibration offset is stored in the RedPitayas EEPROM and is applied in the background.","category":"page"},{"location":"generation.html#Sequences","page":"Signal Generation","title":"Sequences","text":"","category":"section"},{"location":"generation.html","page":"Signal Generation","title":"Signal Generation","text":"The FPGA image features a LUT containing values for all output channels. This LUT is treated as a ring-buffer through which the image iterates and outputs the values on their respective channel. The image can be configured to increment its LUT access every n samples. One period of a value is also called a step.","category":"page"},{"location":"generation.html","page":"Signal Generation","title":"Signal Generation","text":"As the LUT used by the FPGA image is small in comparison with the main memory and to support longer series of steps, the server itselfs maintains a list of sequences. A sequence is a series of steps and the number of times this series is to be repeated. During an acqusition and the parallel signal generation the server periodically reads the next steps from its sequence list and writes them to the LUT of the image.","category":"page"},{"location":"generation.html","page":"Signal Generation","title":"Signal Generation","text":"Comparable to the sample transmission of the acquisition, this updating of the LUT is also a process with timing uncertainty as it is affected by the scheduling and execution of the RedPitayas CPU. While during the sample transmission samples could be lost because they were overwritten, in the signal generation wrong signals could be output because the server was too slow in updating the values. Here, the server tracks similar performance metrics and also features a status flag lostSteps for exactly this case. In its current implementation a safe step rate is at 12 kHz.","category":"page"},{"location":"generation.html","page":"Signal Generation","title":"Signal Generation","text":"Sequences and their steps also have additional features. A step can be marked such that during its duration the signal is set to 0. The last step of a sequence can also be marked such that the phase of the waveforms is reset to 0 for the following sequence. This involves adding an additional reset step.","category":"page"},{"location":"connections.html#Connections","page":"Connections","title":"Connections","text":"","category":"section"},{"location":"connections.html","page":"Connections","title":"Connections","text":"An overview of the extension connectors (see also here) is given in the following image","category":"page"},{"location":"connections.html","page":"Connections","title":"Connections","text":"(Image: Connectors)","category":"page"},{"location":"connections.html","page":"Connections","title":"Connections","text":"The project uses most but not all connections that are used in the original RedPitaya image. From the connector E2 only the analog inputs and outputs are used. From the connector E1 several pins are reserved for the following purposes:","category":"page"},{"location":"connections.html","page":"Connections","title":"Connections","text":"DIO0_P for the ADC and DAC trigger. Connect it with the master's DIO5_P to distribute the trigger signal to all RPs including the master. As long as the input is high, the DACs and ADCs are running.\nDIO1_P is the input for the watchdog (see configuration register section for further details)\nDIO2_P is used to acknowledge a received watchdog signal.\nDIO3_P can be set to high, to stop all DACs instantly.\nDIO4_P outputs a high for 10 ms after a 100 ms pause on low to provide an alive signal.\nDIO5_P can be set to high via the configuration register to provide the mutual trigger signal.\nDIO7_P, DIO7_N, DIO6_P, DIO6_N, DIO5_N, DIO4_N, DIO3_N, DIO2_N can be used as arbitrary outputs set via the server.","category":"page"},{"location":"examples/cluster.html#Cluster-Example","page":"Cluster","title":"Cluster Example","text":"","category":"section"},{"location":"examples/cluster.html","page":"Cluster","title":"Cluster","text":"In this example we generate and acquire sine waves, similar to to the first example. However, this time we use two RedPitayas sychronized in a cluster. The example will create a sine wave on the first DAC channel of the first RedPitaya and a phase shifted sine wave on the first channel of the second RedPitaya. To run this example connect the RedPitayas in the following way:","category":"page"},{"location":"examples/cluster.html","page":"Cluster","title":"Cluster","text":"(Image: RedPitaya)","category":"page"},{"location":"examples/cluster.html","page":"Cluster","title":"Cluster","text":"Note that while the example only plots the first channel of the RedPitaya, both channels are transmitted to the clients.","category":"page"},{"location":"examples/cluster.html#Julia-Client","page":"Cluster","title":"Julia Client","text":"","category":"section"},{"location":"examples/cluster.html","page":"Cluster","title":"Cluster","text":"This and all other examples are located in the examples directory","category":"page"},{"location":"examples/cluster.html","page":"Cluster","title":"Cluster","text":"# Adapted from https://github.com/JuliaDocs/Documenter.jl/issues/499\nusing Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(open(f->read(f, String), \"../../../src/examples/julia/cluster.jl\"))\n```\n\"\"\")","category":"page"},{"location":"examples/sequenceMultiChannel.html#Sequence-Multi-Channel-and-Waveform-Enable-Example","page":"Sequence Multi-Channel and Waveform Enable","title":"Sequence Multi-Channel and Waveform Enable Example","text":"","category":"section"},{"location":"examples/sequenceMultiChannel.html","page":"Sequence Multi-Channel and Waveform Enable","title":"Sequence Multi-Channel and Waveform Enable","text":"This examples combines concepts from the three examples and additionally uses the signal enable feature of the sequences. This example uses both DAC and ADC channels of the RedPitaya. On the first DAC channel we output a square waveform composed with a climbing sequence. On the second channel we output just a sequence with a constant value and no waveforms at all. The signal enable flags of the sequences are set in such a way, that the two channels alternate being enabled with each step.","category":"page"},{"location":"examples/sequenceMultiChannel.html","page":"Sequence Multi-Channel and Waveform Enable","title":"Sequence Multi-Channel and Waveform Enable","text":"(Image: RedPitaya)","category":"page"},{"location":"examples/sequenceMultiChannel.html#Julia-Client","page":"Sequence Multi-Channel and Waveform Enable","title":"Julia Client","text":"","category":"section"},{"location":"examples/sequenceMultiChannel.html","page":"Sequence Multi-Channel and Waveform Enable","title":"Sequence Multi-Channel and Waveform Enable","text":"This and all other examples are located in the examples directory","category":"page"},{"location":"examples/sequenceMultiChannel.html","page":"Sequence Multi-Channel and Waveform Enable","title":"Sequence Multi-Channel and Waveform Enable","text":"# Adapted from https://github.com/JuliaDocs/Documenter.jl/issues/499\nusing Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(open(f->read(f, String), \"../../../src/examples/julia/sequence.jl\"))\n```\n\"\"\")","category":"page"},{"location":"examples/sequenceMultiChannel.html","page":"Sequence Multi-Channel and Waveform Enable","title":"Sequence Multi-Channel and Waveform Enable","text":"(Image: Simple Example Results)","category":"page"},{"location":"installation.html#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation.html#Alpine-Linux-Image","page":"Installation","title":"Alpine Linux Image","text":"","category":"section"},{"location":"installation.html","page":"Installation","title":"Installation","text":"The RedPitayaDAQServer project uses a custom RedPitaya image that was derived from the red-pitaya-notes project. It consists of an Alpine Linux with some development tools installed. Additionally the image reserves the upper 128 MB of main memory for the FPGA, which is used as a buffer for recording the data from the ADCs. The Linux image can be downloaded here. Just unzip the zip file and copy the content on an empty SD card that is formatted in FAT32.","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"If you want to build the Linux image yourself, you can install Xilinx Vitis and Vivado (2021.2) in an Ubuntu environment (bare metal or virtual machine). Then run","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"sudo apt-get update\n\nsudo apt-get --no-install-recommends install \\\n  build-essential bison flex git curl ca-certificates sudo \\\n  xvfb fontconfig libxrender1 libxtst6 libxi6 make \\\n  bc u-boot-tools device-tree-compiler libncurses5-dev \\\n  libssl-dev qemu-user-static binfmt-support zip \\\n  squashfs-tools dosfstools parted debootstrap zerofree","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"in order to get the essential tools. Afterwards clone the project with","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"git clone https://github.com/tknopp/RedPitayaDAQServer","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"Then switch into this directory. You can build the whole project using","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"make all","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"For only building some parts, such as the FPGA image, please refer to the Makefile.","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"Note: make has to be run as root if you want to build the Linux image, since chroot requires root privileges.","category":"page"},{"location":"installation.html#Setting-Up-the-Server","page":"Installation","title":"Setting Up the Server","text":"","category":"section"},{"location":"installation.html","page":"Installation","title":"Installation","text":"Next you need to install the server application. To this end, connect the RedPitaya to you local network and access the device via ssh:","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"ssh root@rp-f?????.local","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"where ????? is the ID that is printed on the RedPitaya. The default password is root. After logging into the RedPitaya go to the folder","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"/root/apps/","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"and clone the RedPitayaDAQServer project:","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"git clone https://github.com/tknopp/RedPitayaDAQServer","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"Sometimes you might need to make the file system writable by entering","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"mount -o remount,rw /dev/mmcblk0p1","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"Then cd into RedPitayaDAQServer","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"cd /root/apps/RedPitayaDAQServer","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"and enter make server. This will compile the library, the server, and some example applications. After you restart the RedPitaya the DAQ server will automatically run and you can access it via TCP.","category":"page"},{"location":"installation.html#Setting-Up-the-Julia-Client-Library","page":"Installation","title":"Setting Up the Julia Client Library","text":"","category":"section"},{"location":"installation.html","page":"Installation","title":"Installation","text":"For the Julia client library you need to install RedPitayaDAQServer within Julia. To this end download Julia 1.5 or later and go into the package manager mode by intering ]. Then there are two options to install the client library.","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"add RedPitayaDAQServer:src/client/julia\ndev RedPitayaDAQServer:src/client/julia","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"The first is installing the currently published version. The second is installing in development mode and put the files to ~/dev/RedPitayaDAQServer/ where you can the also modify the files, which is handy when trying out the examples. Right now we recommend to dev the package. You need to git pull from ~/dev/RedPitayaDAQServer/ if you want to get updates, i.e. Julia will not update developed packages automatically.","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"The client library is not an executable data acquisition program, but it can be used to implement one. The library encapsulates the communication with the server and implements various optimizations. As the communication with the server is language agnostic and one could therefore implement their own client in a different language. The Julia reference client library found in src/client/julia, the SCPI commands and the sections on the signal acquisition and generation are starting points for such a custom client.","category":"page"},{"location":"examples/waveforms.html#Waveforms-Example","page":"Waveforms","title":"Waveforms Example","text":"","category":"section"},{"location":"examples/waveforms.html","page":"Waveforms","title":"Waveforms","text":"In this example we generate different signals with a base frequency of 10 kHz on DAC channel 1 and receive the same signals on the ADC channel 1. To run this example connect the RedPitaya in the following way.","category":"page"},{"location":"examples/waveforms.html","page":"Waveforms","title":"Waveforms","text":"(Image: RedPitaya)","category":"page"},{"location":"examples/waveforms.html","page":"Waveforms","title":"Waveforms","text":"It is also possible to update the signal type during the acquisition without going back to the CONFIGURATION mode.","category":"page"},{"location":"examples/waveforms.html#Julia-Client","page":"Waveforms","title":"Julia Client","text":"","category":"section"},{"location":"examples/waveforms.html","page":"Waveforms","title":"Waveforms","text":"This and all other examples are located in the examples directory","category":"page"},{"location":"examples/waveforms.html","page":"Waveforms","title":"Waveforms","text":"# Adapted from https://github.com/JuliaDocs/Documenter.jl/issues/499\nusing Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(open(f->read(f, String), \"../../../src/examples/julia/waveforms.jl\"))\n```\n\"\"\")","category":"page"},{"location":"examples/waveforms.html","page":"Waveforms","title":"Waveforms","text":"(Image: Simple Example Results)","category":"page"},{"location":"examples/simple.html#Simple-Example","page":"Simple","title":"Simple Example","text":"","category":"section"},{"location":"examples/simple.html","page":"Simple","title":"Simple","text":"In the first example we connect to a single RedPitaya and generate a sinus signal of frequency 10 kHz on DAC channel 1 and receive the same signal on the ADC channel 1. To run this example connect the RedPitaya in the following way.","category":"page"},{"location":"examples/simple.html","page":"Simple","title":"Simple","text":"(Image: RedPitaya)","category":"page"},{"location":"examples/simple.html","page":"Simple","title":"Simple","text":"Note that while the example only plots the first channel of the RedPitaya, both channels are transmitted to the clients.","category":"page"},{"location":"examples/simple.html#Julia-Client","page":"Simple","title":"Julia Client","text":"","category":"section"},{"location":"examples/simple.html","page":"Simple","title":"Simple","text":"This and all other examples are located in the examples directory","category":"page"},{"location":"examples/simple.html","page":"Simple","title":"Simple","text":"# Adapted from https://github.com/JuliaDocs/Documenter.jl/issues/499\nusing Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(open(f->read(f, String), \"../../../src/examples/julia/simple.jl\"))\n```\n\"\"\")","category":"page"},{"location":"examples/simple.html","page":"Simple","title":"Simple","text":"(Image: Simple Example Results)","category":"page"},{"location":"architecture.html#Architecture","page":"Architecture","title":"Architecture","text":"","category":"section"},{"location":"architecture.html","page":"Architecture","title":"Architecture","text":"The RedPitayaDAQServer project is implemented as a distributed system in which one client connects to a cluster of RedPitaya boards. The project has four software components:","category":"page"},{"location":"architecture.html","page":"Architecture","title":"Architecture","text":"FPGA image running on the RedPitayas FPGA\nC library encapsulating access to the FPGA image\nServer running on the CPU of the RedPitayas\nClient Julia reference library ","category":"page"},{"location":"architecture.html","page":"Architecture","title":"Architecture","text":"The FPGA image is responsible for generating and acquiring sychronized out- and input signals. The server acts as an intermediary to the FPGA over a TCP/IP connection, which allows remote clients to configure the FPGA image and retrieve samples. Furthermore, the server also maintains a thread that takes part in signal generation.","category":"page"},{"location":"architecture.html","page":"Architecture","title":"Architecture","text":"The Julia client library can be used to implement a data acqusition client application, which controls a (cluster of) RedPitaya(s). This Julia library acts as a reference, but in principle it is possible to write clients in any programming language, as the communication is language agnostic.","category":"page"},{"location":"architecture.html#Communication","page":"Architecture","title":"Communication","text":"","category":"section"},{"location":"architecture.html","page":"Architecture","title":"Architecture","text":"The various components of the distributed system communicate over different interfaces. Communication within a RedPitaya is based on memory-mapped I/O, while communication between the server and a client is based on SCPI commands over a TCP/IP connection, usually over Ethernet. Lastly communication between RedPitayas is limited to signals distributed over cables as described in Cluster.","category":"page"},{"location":"architecture.html#FPGA-and-CPU","page":"Architecture","title":"FPGA and CPU","text":"","category":"section"},{"location":"architecture.html","page":"Architecture","title":"Architecture","text":"The FPGA image is directly connected to certain memory regions that can be memory mapped on the CPU side of the RedPitaya. Both the CPU and the FPGA image access the reserved main memory region as a sample buffer. The C library rp-daq-lib located in src/lib/ encapsulates these memory accesses into a convenient C library. It is possible to use this C library directly when no communication with the host system is required, i.e. if one wants to write the acquired data into a file. When making changes to the FPGA image one may need to adapt the rp-daq-lib C library.","category":"page"},{"location":"architecture.html","page":"Architecture","title":"Architecture","text":"The server itself uses the rp-daq-lib library to interface with the FPGA image.","category":"page"},{"location":"architecture.html#Client-and-Server","page":"Architecture","title":"Client and Server","text":"","category":"section"},{"location":"architecture.html","page":"Architecture","title":"Architecture","text":"The server on each RedPitaya has two TCP sockets to which a client needs to connect. The first is the command socket on port 5025 and the second is the data socket on port 5026. Over the former, a client can send SCPI commands to the server and receive replies, while the latter is used for sending binary data such as the samples acquired by the ADCs.","category":"page"},{"location":"architecture.html","page":"Architecture","title":"Architecture","text":"SCPI commands are ASCII strings, such as RP:ADC:DECimation, which the server translates into C function calls. As an example these calls could invoke a function of the rp-daq-lib library to set the decimation of the sampling rate or instruct the server to transmit data over the data socket. A list of the available SCPI commands can be found here.","category":"page"},{"location":"architecture.html","page":"Architecture","title":"Architecture","text":"At any point a server is only connected to one client and establishing a new connection stops any current signal generation and acquisition.","category":"page"},{"location":"fpga.html#FPGA-Development","page":"FPGA Development","title":"FPGA Development","text":"","category":"section"},{"location":"fpga.html","page":"FPGA Development","title":"FPGA Development","text":"There may be needs to change the FPGA image. The following explains how this can be done.","category":"page"},{"location":"fpga.html#Preparation","page":"FPGA Development","title":"Preparation","text":"","category":"section"},{"location":"fpga.html","page":"FPGA Development","title":"FPGA Development","text":"If you want to make changes to the FPGA design, you need to install Vivado 2021.2. More infos for setting up a development machine we refer to the following recource.","category":"page"},{"location":"fpga.html","page":"FPGA Development","title":"FPGA Development","text":"After following the installation steps, you need to clone the repository into a directory of your choice and then regenerate the IP cores and the project by running","category":"page"},{"location":"fpga.html","page":"FPGA Development","title":"FPGA Development","text":"./make_fpga_project.sh.","category":"page"},{"location":"fpga.html","page":"FPGA Development","title":"FPGA Development","text":"Afterwards you can start Vivado and open the recreated project in ./build/fpga/firmware/RedPitayaDAQServer.xpr. Apply the changes you need and then create the bitfile by using 'Flow -> Generate Bitstream'. This runs the synthesis and implementation steps and output the Bitfile to ./build/fpga/firmware/RedPitayaDAQServer.runs/impl_1/system_wrapper.bit.","category":"page"},{"location":"fpga.html","page":"FPGA Development","title":"FPGA Development","text":"After creating the respective bitfile you need to copy it to your Red Pitayas. You can use","category":"page"},{"location":"fpga.html","page":"FPGA Development","title":"FPGA Development","text":"scp ./build/fpga/firmware/RedPitayaDAQServer.runs/impl_1/system_wrapper.bin root@<IP>:/root/RedPitayaDAQServer/bitfiles/daq_<xc7z010clg400-1,xc7z020clg400-1>.bin","category":"page"},{"location":"fpga.html","page":"FPGA Development","title":"FPGA Development","text":"for this. Set your IP and FPGA version accordingly.","category":"page"},{"location":"fpga.html","page":"FPGA Development","title":"FPGA Development","text":"Since using git with Vivado can be annoying here are some hints how you can make your changes ready for git:","category":"page"},{"location":"fpga.html","page":"FPGA Development","title":"FPGA Development","text":"If you only changed some stuff in the blockdesign, you just have to export the blockdesign to ./src/fpga/bd by using 'File -> Export -> Export Block Design' in Vivado.\nChanges to the project settings have to be done in ./src/fpga/build.tcl in order to not lose the ability to recreate your changed project.\nFor your own IP cores, just create a new directory in ./src/fpga/cores and copy and adapt the core_config.tcl of another core. Afterwards re-run make_cores.tcl.","category":"page"},{"location":"acquisition.html#Data-Acqusition","page":"Data Acquisition","title":"Data Acqusition","text":"","category":"section"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"The data acqusition of the RedPitayaDAQServer project is based on two data flows to and from the upper 128 MB of the RedPitaya memory. This memory region acts as a ring buffer for the acquired samples and can be queried by clients using SCPI commands.","category":"page"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"Signal acquisition within a cluster is based on a shared clock and trigger signal distributed via cables between the RedPitayas. Once triggered, all FPGAs continuously write the samples from their ADC channel to the sample ring-buffer with each clock tick. Both ADC channels on a RedPitaya are written to the buffer at the same time. Their 14-bit values are converted to 16-bit signed integer samples and then concatenated into one 32-bit value, which is written to the buffer. The sampling rate of the system can be adjusted by setting a decimation parameter and the decimation itself is realized with a CIC filter.","category":"page"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"Internally, the FPGA keeps track of a 64-bit writepointer register pointing into the ring-buffer and increments this value with each new sample pair. Additionally, the writepointer also counts the number of buffer overflows. As the size of the buffer region is a power of two, these two components of the writepointer can be interpreted as one 64-bit number counting the samples from acquisition start. For the 128 MB buffer, this means that the lower 25 bits of the writepointer are the buffer location and the remaining bits are the overflow counter.","category":"page"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"As the writepointer is reset and incremented based on a shared clock and trigger signal, it is synchronized across all FPGA images in a cluster. The logic implemented with the reprogrammable hardware is also the only logic of the RedPitayaDAQServer with predictable timing behaviour. All other components of the system implement their (timing related) logic in reference to the current writepointer values. With a known sampling rate, the writepointer can also be seen as the clock of the server and client components.","category":"page"},{"location":"acquisition.html#Sample-Transmission","page":"Data Acquisition","title":"Sample Transmission","text":"","category":"section"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"To retrieve samples from the server a client can supply a similar pointer, a readpointer, together with the number of samples to retrieve. The server then extracts the buffer position from the readpointer and transmits the requested amount of samples over the data socket. This transmission happens either way, even if the samples are overwritten. However, the server uses the whole readpointer, including the buffer overflows, to check if the requested samples were overwritten.","category":"page"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"If the distance between the write- and readpointer is larger than the buffer size the overflow status flag is set. If during the transmission the requested samples are overwritten the corrupted flag is set. These flags can be queried individually or together in a status byte via SCPI commands.","category":"page"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"This distance can not only be used to see if samples were overwritten, but also to track how well the client is able to keep up with the FPGA during a series of sample transmissions. If this distance increases over time, the FPGA is creating more samples than the server can transmit to the client. To allow a client to track this value, this distance is stored as a 64-bit value deltaRead for the latest transmission and can be queried. Additionally, the server also tracks the duration of the transmission as writepointer \"clock ticks\" as a 64-bit value deltaSend, which is just the difference between the writepointer at the start and end of a transmission.","category":"page"},{"location":"acquisition.html#Considerations-for-Sample-Transmission","page":"Data Acquisition","title":"Considerations for Sample Transmission","text":"","category":"section"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"There are several things to consider when attempting to retrieve samples at a high sampling rate, larger cluster sizes or for longer periods of time. Most of the following points were implemented/considered in the Julia reference implementation, but would become relevant when implementing custom clients.","category":"page"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"As the server will always transmit samples just based on the buffer position of a readpointer, if a client wants to only receive certain samples it needs to wait for them to exist in the buffer. This requires querying the writepointer until it is larger than the desired readpointer.","category":"page"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"If the number of requested samples is larger than the buffer, the sample should be requested in smaller chunks as the server would otherwise return samples that were not written yet. In a cluster scenario the i-th chunk should be requested from all RedPitayas in the cluster before requesting the next chunk to avoid \"starvation\" effects.","category":"page"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"The status and performance data of a transmission can only be queried after the transmission has finished, which requires additionaly communication overhead.","category":"page"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"To help clients with these issues, the server offers a second type of sample transmission in which samples, status and performance data is pipelined. In such a query a client first transmits a readpointer, together with the number of requested samples and the number of samples belonging to a chunk. The server itself then tracks the writepointer and transmits a chunk as soon as it becomes available and immidiatey follows that up with the status and performance data of the transmission. This way additional communication overheard is reduced and after the inital request a client just needs to read data until the transmission finishes.","category":"page"},{"location":"acquisition.html#Frames,-Periods-and-Voltage","page":"Data Acquisition","title":"Frames, Periods and Voltage","text":"","category":"section"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"The samples sent by the server are the 16-bit values of the ADC channel of a RedPitaya. However, one might want to instead work with voltage values or encapsulate samples into a repeating concept like frames. The Julia client library offers functions to convert samples into such a concept or to directly request a number of frames instead of a number of samples.","category":"page"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"Here, frames are comprised of periods, which in turn are comprised of samples. During the conversion process the 16-bit binary values can also be converted to floating point numbers representing a voltage if the RedPitaya was calibrated beforehand. In this calibration process, a client can store scale and offset values for each channel in the EEPROM of the RedPitaya. When the client establishes a connection to the server, it reads these values and can use them to translate the 16-bit values into a respective voltage value.","category":"page"},{"location":"acquisition.html#Sampling-and-Data-Rates,-Transmission-Speeds-and-Time-to-Live","page":"Data Acquisition","title":"Sampling and Data Rates, Transmission Speeds and Time-to-Live","text":"","category":"section"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"The highest supported sampling rate of the RedPitayaDAQServer is 15.625 MHz or 15.625 MS/s, as this is the sampling rate at which a single RedPitaya can produce and transmit samples continously without data loss given the 1 Gbit/s limit of the ethernet connection from the RedPitaya. This rate is a achieved with a decimation of 8 from the base 125 MHz sampling rate of the RedPitaya hardware.","category":"page"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"At this sampling rate a single RedPitaya produces new samples at a data rate of 500 Mbit/s. Furthermore at this rate, once a sample has been written to the buffer it exists for 2.15s before being overwritten again. An overview of these metrics for different decimation factors is shown in the following table:","category":"page"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"Decimation MHz MByte/s Mbit/s TTL\n64 1.95 7.81 62.5 17.18s\n32 3.91 15.63 125 8.59s\n16 7.81 31.25 250 4.29s\n8 15.63 62.5 500 2.15s","category":"page"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"The table only refers to the data rate of new samples being produced. The data rate of samples being transmitted to a client can differ greatly depending on how the client queries and processes the samples and the available network bandwidth and usage. At the higher sampling rates it is recommended to have client threads that exclusively receive samples and perform any computation on samples in different threads to maximise the transmission speed, as a server can only transmit data at a rate of just above 500 Mbit/s.","category":"page"},{"location":"cluster.html#Cluster","page":"Cluster","title":"Cluster","text":"","category":"section"},{"location":"cluster.html","page":"Cluster","title":"Cluster","text":"The RedPitayaDAQServer allows to use multiple RedPitayas in a fully synchronized fashion. One of the RedPitayas will act as the master and distribute its clock to all other RedPitayas acting as slaves.","category":"page"},{"location":"cluster.html#Prerequisites","page":"Cluster","title":"Prerequisites","text":"","category":"section"},{"location":"cluster.html","page":"Cluster","title":"Cluster","text":"Unfortunately, the STEMlab 125-4 does not allow cluster synchronization without hardware modifications.   It is therefore necessary to resolder all slaves according to this documentation. The required mode for this project is 'Directly from FPGA'. The heatsink has to be removed temporarily in order to unsolder the two resistor below it. In the following image you can see the new position of the 0 Ohm 0402 resistors. Since they get lost easily, make sure you have some in stock.","category":"page"},{"location":"cluster.html","page":"Cluster","title":"Cluster","text":"(Image: Cluster)","category":"page"},{"location":"cluster.html#Connections","page":"Cluster","title":"Connections","text":"","category":"section"},{"location":"cluster.html","page":"Cluster","title":"Cluster","text":"To run a cluster of RedPitayas one needs to connect the devices using different cables. An exemplary cluster with 3 devices is shown in the following image.","category":"page"},{"location":"cluster.html","page":"Cluster","title":"Cluster","text":"(Image: Cluster)","category":"page"},{"location":"cluster.html","page":"Cluster","title":"Cluster","text":"The clock is distributed from the master to the first slave via an SATA cable (green). Additional slaves can be used by connecting the next slave to the previous one. Additionally all slaves have connection from +3.3 Volt to DIO0_N.","category":"page"},{"location":"cluster.html","page":"Cluster","title":"Cluster","text":"In order to send a mutual trigger signal for starting the acquisition and the signal generation, you also have to connect the master's DIO5_P pin (see link) with the DIO0_P pin of all devices including the master.","category":"page"},{"location":"client.html#Client","page":"Client Library","title":"Client","text":"","category":"section"},{"location":"client.html","page":"Client Library","title":"Client Library","text":"This page contains documentation of the public API of the Julia client. In the Julia REPL one can access this documentation by entering the help mode with ? and then writing the function for which the documentation should be shown.","category":"page"},{"location":"client.html#Connection-and-Communication","page":"Client Library","title":"Connection and Communication","text":"","category":"section"},{"location":"client.html","page":"Client Library","title":"Client Library","text":"RedPitayaDAQServer.RedPitaya\nRedPitayaDAQServer.RedPitaya(::String, ::Int64, ::Int64, ::Bool)\nRedPitayaDAQServer.send(::RedPitaya, ::String)\nRedPitayaDAQServer.query\nRedPitayaDAQServer.receive\nRedPitayaDAQServer.RedPitayaCluster\nRedPitayaDAQServer.RedPitayaCluster(::Vector{String}, ::Int64, ::Int64)\nRedPitayaDAQServer.master","category":"page"},{"location":"client.html#RedPitayaDAQServer.RedPitaya","page":"Client Library","title":"RedPitayaDAQServer.RedPitaya","text":"RedPitaya\n\nStruct representing a connection to a RedPitayaDAQServer.\n\nContains the sockets used for communication and connection related metadata. Also contains fields for  client specific concepts such as periods, frames and calibration values. \n\n\n\n\n\n","category":"type"},{"location":"client.html#RedPitayaDAQServer.RedPitaya-Tuple{String, Int64, Int64, Bool}","page":"Client Library","title":"RedPitayaDAQServer.RedPitaya","text":"RedPitaya(ip [, port = 5025, dataPort=5026, isMaster = false])\n\nConstruct a RedPitaya.\n\nDuring the construction the connection is established and the calibration values are loaded from the RedPitayas EEPROM. Throws an error if a timeout occurs while attempting to connect.\n\nExamples\n\njulia> rp = RedPitaya(\"192.168.1.100\");\n\njulia> decimation!(rp, 8)\ntrue\n\njulia> decimation(rp)\n8\n\n\n\n\n\n","category":"method"},{"location":"client.html#Sockets.send-Tuple{RedPitaya, String}","page":"Client Library","title":"Sockets.send","text":"send(rp::RedPitaya, cmd::String)\n\nSend a command to the RedPitaya. Appends delimiter.\n\n\n\n\n\n","category":"method"},{"location":"client.html#RedPitayaDAQServer.query","page":"Client Library","title":"RedPitayaDAQServer.query","text":"query(rp::RedPitaya, cmd [, timeout = 5.0, N = 100])\n\nSend a query to the RedPitaya command socket. Return reply as String.\n\nWaits for timeout seconds and checks every timeout/N seconds.\n\nSee also receive.\n\n\n\n\n\nquery(rp::RedPitaya, cmd, T::Type [timeout = 5.0, N = 100])\n\nSend a query to the RedPitaya. Parse reply as T.\n\nWaits for timeout seconds and checks every timeout/N seconds.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.receive","page":"Client Library","title":"RedPitayaDAQServer.receive","text":"receive(rp::RedPitaya)\n\nReceive a String from the RedPitaya command socket. Reads until a whole line is received\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.RedPitayaCluster","page":"Client Library","title":"RedPitayaDAQServer.RedPitayaCluster","text":"RedPitayaCluster\n\nStruct representing a cluster of RedPitayas. Such a cluster should share a common clock and master trigger.\n\nThe structure implements the indexing and iterable interfaces.\n\n\n\n\n\n","category":"type"},{"location":"client.html#RedPitayaDAQServer.RedPitayaCluster-Tuple{Vector{String}, Int64, Int64}","page":"Client Library","title":"RedPitayaDAQServer.RedPitayaCluster","text":"RedPitayaCluster(hosts::Vector{String} [, port = 5025])\n\nConstruct a RedPitayaCluster.\n\nDuring the construction the first host is labelled the master RedPitaya of a cluster and all RedPitayas are set to using the EXTERNAL trigger mode.\n\nSee also RedPitaya, master.\n\nExamples\n\njulia> rpc = RedPitayaCluster([\"192.168.1.100\", \"192.168.1.101\"]);\n\njulia> rp = master(rpc)\n\njulia> rp == rpc[1]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"client.html#RedPitayaDAQServer.master","page":"Client Library","title":"RedPitayaDAQServer.master","text":"master(rpc::RedPitayaCluster)\n\nReturn the master RedPitaya of the cluster.\n\n\n\n\n\n","category":"function"},{"location":"client.html#ADC-Configuration","page":"Client Library","title":"ADC Configuration","text":"","category":"section"},{"location":"client.html","page":"Client Library","title":"Client Library","text":"RedPitayaDAQServer.TriggerMode\nRedPitayaDAQServer.triggerMode\nRedPitayaDAQServer.triggerMode!\nRedPitayaDAQServer.keepAliveReset\nRedPitayaDAQServer.keepAliveReset!\nRedPitayaDAQServer.decimation\nRedPitayaDAQServer.decimation!\nRedPitayaDAQServer.numChan\nRedPitayaDAQServer.samplesPerPeriod\nRedPitayaDAQServer.samplesPerPeriod!\nRedPitayaDAQServer.periodsPerFrame\nRedPitayaDAQServer.periodsPerFrame!","category":"page"},{"location":"client.html#RedPitayaDAQServer.TriggerMode","page":"Client Library","title":"RedPitayaDAQServer.TriggerMode","text":"TriggerMode\n\nRepresent the different trigger modes the FPGA image can have. Valid value are INTERNAL and EXTERNAL.\n\nSee triggerMode, triggerMode!.\n\n\n\n\n\n","category":"type"},{"location":"client.html#RedPitayaDAQServer.triggerMode","page":"Client Library","title":"RedPitayaDAQServer.triggerMode","text":"triggerMode(rpc::RedPitayaCluster)\n\nAs with single RedPitaya, but applied to only the master.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.triggerMode!","page":"Client Library","title":"RedPitayaDAQServer.triggerMode!","text":"triggerMode!(rp::RedPitaya, mode::String)\n\nSet the trigger mode of the RedPitaya. Return true if the command was successful.\n\n\n\n\n\ntriggerMode!(rp::RedPitaya, mode::String)\n\nSet the trigger mode of the RedPitaya. Return true if the command was successful.\n\n\n\n\n\ntriggerMode!(rpc::RedPitayaCluster, value)\n\nAs with single RedPitaya, but applied to all RedPitayas in a cluster.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.keepAliveReset","page":"Client Library","title":"RedPitayaDAQServer.keepAliveReset","text":"keepAliveReset(rp::RedPitaya)\n\nDetermine whether the keepAliveReset is set.\n\n\n\n\n\nkeepAliveReset(rpc::RedPitayaCluster)\n\nAs with single RedPitaya, but applied to only the master.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.keepAliveReset!","page":"Client Library","title":"RedPitayaDAQServer.keepAliveReset!","text":"keepAliveReset!(rp::RedPitaya, val::Bool)\n\nSet the keepAliveReset to val.\n\n\n\n\n\nkeepAliveReset!(rpc::RedPitayaCluster, value)\n\nAs with single RedPitaya, but applied to all RedPitayas in a cluster.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.decimation","page":"Client Library","title":"RedPitayaDAQServer.decimation","text":"decimation(rp::RedPitaya)\n\nReturn the decimation of the RedPitaya.\n\nExamples\n\njulia> decimation!(rp, 8)\ntrue\n\njulia> decimation(rp)\n8\n\n\n\n\n\ndecimation(rpc::RedPitayaCluster)\n\nAs with single RedPitaya, but applied to only the master.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.decimation!","page":"Client Library","title":"RedPitayaDAQServer.decimation!","text":"decimation!(rp::RedPitaya, dec)\n\nSet the decimation of the RedPitaya. Return true if the command was successful.\n\nExamples\n\njulia> decimation!(rp, 8)\ntrue\n\njulia> decimation(rp)\n8\n\n\n\n\n\ndecimation!(rpc::RedPitayaCluster, value)\n\nAs with single RedPitaya, but applied to all RedPitayas in a cluster.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.numChan","page":"Client Library","title":"RedPitayaDAQServer.numChan","text":"numChan(rp::RedPitaya)\n\nReturn the number of ADC channel of a RedPitaya.\n\n\n\n\n\nnumChan(rpc::RedPitayaCluster)\n\nReturn the number of ADC channel in cluser rpc.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.samplesPerPeriod","page":"Client Library","title":"RedPitayaDAQServer.samplesPerPeriod","text":"samplesPerPeriod(rp::RedPitaya)\n\nReturn the number of samples per period.\n\nExample\n\njulia> samplesPerPeriod!(rp, 256)\ntrue\n\njulia> samplesPerPeriod(rp)\n256\n\n\n\n\n\n\nsamplesPerPeriod(rpc::RedPitayaCluster)\n\nAs with single RedPitaya, but applied to only the master.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.samplesPerPeriod!","page":"Client Library","title":"RedPitayaDAQServer.samplesPerPeriod!","text":"samplesPerPeriod!(rp::RedPitaya, value)\n\nSet the number of samples per period.\n\nExample\n\njulia> samplesPerPeriod!(rp, 256)\ntrue\n\njulia> samplesPerPeriod(rp)\n256\n\n\n\n\n\n\nsamplesPerPeriod!(rpc::RedPitayaCluster, value)\n\nAs with single RedPitaya, but applied to all RedPitayas in a cluster.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.periodsPerFrame","page":"Client Library","title":"RedPitayaDAQServer.periodsPerFrame","text":"periodsPerFrame(rp::RedPitaya)\n\nReturn the number of periods per frame.\n\nExample\n\njulia> periodsPerFrame!(rp, 16)\n\njulia> periodsPerFrame(rp)\n16\n\n\n\n\n\n\nperiodsPerFrame(rpc::RedPitayaCluster)\n\nAs with single RedPitaya, but applied to only the master.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.periodsPerFrame!","page":"Client Library","title":"RedPitayaDAQServer.periodsPerFrame!","text":"periodsPerFrame(rp::RedPitaya, value)\n\nSet the number of periods per frame.\n\nExample\n\njulia> periodsPerFrame!(rp, 16)\n\njulia> periodsPerFrame(rp)\n16\n\n\n\n\n\n\nperiodsPerFrame!(rpc::RedPitayaCluster, value)\n\nAs with single RedPitaya, but applied to all RedPitayas in a cluster.\n\n\n\n\n\n","category":"function"},{"location":"client.html#DAC-Configuration","page":"Client Library","title":"DAC Configuration","text":"","category":"section"},{"location":"client.html","page":"Client Library","title":"Client Library","text":"RedPitayaDAQServer.amplitudeDAC\nRedPitayaDAQServer.amplitudeDAC!\nRedPitayaDAQServer.offsetDAC\nRedPitayaDAQServer.offsetDAC!\nRedPitayaDAQServer.frequencyDAC\nRedPitayaDAQServer.frequencyDAC!\nRedPitayaDAQServer.phaseDAC\nRedPitayaDAQServer.phaseDAC!\nRedPitayaDAQServer.jumpSharpnessDAC\nRedPitayaDAQServer.jumpSharpnessDAC!\nRedPitayaDAQServer.SignalType\nRedPitayaDAQServer.signalTypeDAC\nRedPitayaDAQServer.signalTypeDAC!\nRedPitayaDAQServer.numSeqChan\nRedPitayaDAQServer.numSeqChan!\nRedPitayaDAQServer.samplesPerStep\nRedPitayaDAQServer.samplesPerStep!\nRedPitayaDAQServer.stepsPerFrame!\nRedPitayaDAQServer.AbstractSequence\nRedPitayaDAQServer.appendSequence!\nRedPitayaDAQServer.prepareSequence!\nRedPitayaDAQServer.clearSequences!\nRedPitayaDAQServer.popSequence!\nRedPitayaDAQServer.length(::AbstractSequence)\nRedPitayaDAQServer.start\nRedPitayaDAQServer.ArbitrarySequence\nRedPitayaDAQServer.ArbitrarySequence(lut, enable, repetitions, upSteps, upTotalSteps, downSteps, downTotalSteps, reset)","category":"page"},{"location":"client.html#RedPitayaDAQServer.amplitudeDAC","page":"Client Library","title":"RedPitayaDAQServer.amplitudeDAC","text":"amplitudeDAC(rp::RedPitaya, channel, component)\n\nReturn the amplitude of composite waveform component for channel.\n\nSee amplitudeDAC!.\n\nExamples\n\njulia> amplitudeDAC!(rp, 1, 1, 0.5);\ntrue\n\njulia> amplitudeDAC(rp, 1, 1)\n0.5\n\n\n\n\n\namplitudeDAC(rpc::RedPitayaCluster, chan::Integer, component::Integer)\n\nAs with single RedPitaya. The chan index refers to the total channel available in a cluster, two per RedPitaya. For example channel 4 would refer to the second channel of the second RedPitaya. \n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.amplitudeDAC!","page":"Client Library","title":"RedPitayaDAQServer.amplitudeDAC!","text":"amplitudeDAC!(rp::RedPitaya, channel, component, value)\n\nSet the amplitude of composite waveform component for channel. Return true if the command was successful.\n\nSee amplitudeDAC.\n\nExamples\n\njulia> amplitudeDAC!(rp, 1, 1, 0.5);\ntrue\n\njulia> amplitudeDAC(rp, 1, 1)\n0.5\n\n\n\n\n\namplitudeDAC!(rpc::RedPitayaCluster, chan::Integer, component::Integer, value)\n\nAs with single RedPitaya. The chan index refers to the total channel available in a cluster, two per RedPitaya. For example channel 4 would refer to the second channel of the second RedPitaya.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.offsetDAC","page":"Client Library","title":"RedPitayaDAQServer.offsetDAC","text":"offsetDAC(rp::RedPitaya, channel)\n\nReturn the offset for channel.\n\nSee offsetDAC!.\n\nExamples\n\njulia> offsetDAC!(rp, 1, 0.2);\ntrue\n\njulia> offsetDAC(rp, 1)\n0.2\n\n\n\n\n\noffsetDAC(rpc::RedPitayaCluster, chan::Integer)\n\nAs with single RedPitaya. The chan index refers to the total channel available in a cluster, two per RedPitaya. For example channel 4 would refer to the second channel of the second RedPitaya.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.offsetDAC!","page":"Client Library","title":"RedPitayaDAQServer.offsetDAC!","text":"offsetDAC!(rp::RedPitaya, channel, value)\n\nSet the offset for channel. Return true if the command was successful.\n\nSee offsetDAC.\n\nExamples\n\njulia> offsetDAC!(rp, 1, 0.2);\ntrue\n\njulia> offsetDAC(rp, 1)\n0.2\n\n\n\n\n\noffsetDAC!(rpc::RedPitayaCluster, chan::Integer, value)\n\nAs with single RedPitaya. The chan index refers to the total channel available in a cluster, two per RedPitaya. For example channel 4 would refer to the second channel of the second RedPitaya.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.frequencyDAC","page":"Client Library","title":"RedPitayaDAQServer.frequencyDAC","text":"frequencyDAC(rp::RedPitaya, channel, component)\n\nReturn the frequency of composite waveform component for channel.\n\nSee frequencyDAC!.\n\nExamples\n\njulia> frequencyDAC!(rp, 1, 1, 2400);\ntrue\n\njulia> frequencyDAC(rp, 1, 1)\n2400\n\n\n\n\n\nfrequencyDAC(rpc::RedPitayaCluster, chan::Integer, component::Integer)\n\nAs with single RedPitaya. The chan index refers to the total channel available in a cluster, two per RedPitaya. For example channel 4 would refer to the second channel of the second RedPitaya. \n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.frequencyDAC!","page":"Client Library","title":"RedPitayaDAQServer.frequencyDAC!","text":"frequencyDAC!(rp::RedPitaya, channel, component, value)\n\nSet the frequency of composite waveform component for channel. Return true if the command was successful.\n\nSee frequencyDAC.\n\nExamples\n\njulia> frequencyDAC!(rp, 1, 1, 2400);\ntrue\n\njulia> frequencyDAC(rp, 1, 1)\n2400\n\n\n\n\n\nfrequencyDAC!(rpc::RedPitayaCluster, chan::Integer, component::Integer, value)\n\nAs with single RedPitaya. The chan index refers to the total channel available in a cluster, two per RedPitaya. For example channel 4 would refer to the second channel of the second RedPitaya.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.phaseDAC","page":"Client Library","title":"RedPitayaDAQServer.phaseDAC","text":"phaseDAC(rp::RedPitaya, channel, component)\n\nReturn the phase of composite waveform component for channel.\n\nSee phaseDAC!.\n\nExamples\n\njulia> phaseDAC!(rp, 1, 1, 0.0);\ntrue\n\njulia> phaseDAC(rp, 1, 0.0)\n0.0\n\n\n\n\n\nphaseDAC(rpc::RedPitayaCluster, chan::Integer, component::Integer)\n\nAs with single RedPitaya. The chan index refers to the total channel available in a cluster, two per RedPitaya. For example channel 4 would refer to the second channel of the second RedPitaya. \n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.phaseDAC!","page":"Client Library","title":"RedPitayaDAQServer.phaseDAC!","text":"phaseDAC!(rp::RedPitaya, channel, component, value)\n\nSet the phase of composite waveform component for channel. Return true if the command was successful.\n\nSee phaseDAC.\n\nExamples\n\njulia> phaseDAC!(rp, 1, 1, 0.0);\ntrue\n\njulia> phaseDAC(rp, 1, 0.0)\n0.0\n\n\n\n\n\nphaseDAC!(rpc::RedPitayaCluster, chan::Integer, component::Integer, value)\n\nAs with single RedPitaya. The chan index refers to the total channel available in a cluster, two per RedPitaya. For example channel 4 would refer to the second channel of the second RedPitaya.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.jumpSharpnessDAC","page":"Client Library","title":"RedPitayaDAQServer.jumpSharpnessDAC","text":"jumpSharpnessDAC(rp::RedPitaya, channel, value)\n\nReturn the jumpSharpness of composite waveform for channel.\n\nSee jumpSharpnessDAC!.\n\nExamples\n\njulia> jumpSharpnessDAC!(rp, 1, 0.01);\ntrue\n\njulia> jumpSharpnessDAC(rp, 1)\n0.01\n\n\n\n\n\njumpSharpnessDAC(rpc::RedPitayaCluster, chan::Integer)\n\nAs with single RedPitaya. The chan index refers to the total channel available in a cluster, two per RedPitaya. For example channel 4 would refer to the second channel of the second RedPitaya.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.jumpSharpnessDAC!","page":"Client Library","title":"RedPitayaDAQServer.jumpSharpnessDAC!","text":"jumpSharpnessDAC!(rp::RedPitaya, channel, value)\n\nSet the jumpSharpness of composite waveform for channel. Return true if the command was successful.\n\nSee jumpSharpnessDAC.\n\nExamples\n\njulia> jumpSharpnessDAC!(rp, 1, 0.01);\ntrue\n\njulia> jumpSharpnessDAC(rp, 1)\n0.01\n\n\n\n\n\njumpSharpnessDAC!(rpc::RedPitayaCluster, chan::Integer, value)\n\nAs with single RedPitaya. The chan index refers to the total channel available in a cluster, two per RedPitaya. For example channel 4 would refer to the second channel of the second RedPitaya.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.SignalType","page":"Client Library","title":"RedPitayaDAQServer.SignalType","text":"SignalType\n\nRepresent the different types of signals the fast DAC can have. Valid values are SINE, SQUARE, TRIANGLE and SAWTOOTH.\n\nSee signalTypeDAC, signalTypeDAC!.\n\n\n\n\n\n","category":"type"},{"location":"client.html#RedPitayaDAQServer.signalTypeDAC","page":"Client Library","title":"RedPitayaDAQServer.signalTypeDAC","text":"signalTypeDAC!(rp::RedPitaya, channel, value)\n\nReturn the signalType of composite waveform for channel.\n\nSee signalTypeDAC!.\n\nExamples\n\njulia> signalTypeDAC!(rp, 1, SINE);\ntrue\n\njulia> signalTypeDAC(rp, 1)\nSINE\n\n\n\n\n\nsignalTypeDAC(rpc::RedPitayaCluster, chan::Integer)\n\nAs with single RedPitaya. The chan index refers to the total channel available in a cluster, two per RedPitaya. For example channel 4 would refer to the second channel of the second RedPitaya.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.signalTypeDAC!","page":"Client Library","title":"RedPitayaDAQServer.signalTypeDAC!","text":"signalTypeDAC!(rp::RedPitaya, channel, value)\n\nSet the signalType of composite waveform for channel. Return true if the command was successful.\n\nSee signalTypeDAC.\n\nExamples\n\njulia> signalTypeDAC!(rp, 1, SINE);\ntrue\n\njulia> signalTypeDAC(rp, 1)\nSINE\n\n\n\n\n\nsignalTypeDAC!(rpc::RedPitayaCluster, chan::Integer, value)\n\nAs with single RedPitaya. The chan index refers to the total channel available in a cluster, two per RedPitaya. For example channel 4 would refer to the second channel of the second RedPitaya.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.numSeqChan","page":"Client Library","title":"RedPitayaDAQServer.numSeqChan","text":"numSeqChan(rp::RedPitaya)\n\nReturn the number of sequence channel.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.numSeqChan!","page":"Client Library","title":"RedPitayaDAQServer.numSeqChan!","text":"numSeqChan(rp::RedPitaya, value)\n\nSet the number of sequence channel. Valid values are between 1 and 4. Return true if the command was successful.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.samplesPerStep","page":"Client Library","title":"RedPitayaDAQServer.samplesPerStep","text":"samplesPerStep(rp::RedPitaya)\n\nReturn the number of samples per sequence step.\n\n\n\n\n\nsamplesPerStep(rpc::RedPitayaCluster)\n\nAs with single RedPitaya, but applied to only the master.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.samplesPerStep!","page":"Client Library","title":"RedPitayaDAQServer.samplesPerStep!","text":"samplesPerStep!(rp::RedPitaya, value::Integer)\n\nSet the number of samples per sequence step. Return true if the command was successful.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.stepsPerFrame!","page":"Client Library","title":"RedPitayaDAQServer.stepsPerFrame!","text":"stepsPerFrame!(rp::RedPitaya, stepsPerFrame)\n\nSet the number of samples per steps s.t. stepsPerFrame sequence steps in a frame.\n\nSee samplesPerPeriod!, periodsPerFrame!, samplesPerStep!.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.AbstractSequence","page":"Client Library","title":"RedPitayaDAQServer.AbstractSequence","text":"AbstractSequence\n\nAbstract struct of client-side representation of a sequence.\n\nSee appendSequence!, prepareSequence!, ArbitrarySequence.\n\n\n\n\n\n","category":"type"},{"location":"client.html#RedPitayaDAQServer.appendSequence!","page":"Client Library","title":"RedPitayaDAQServer.appendSequence!","text":"appendSequence!(rp::RedPitaya, seq::AbstractSequence)\n\nTransmit the client-side representation seq to the server and append it to the current list of sequences. Return true if the required commands were successful.\n\nSee prepareSequence!, clearSequences!.\n\n\n\n\n\nappendSequence!(rpc::RedPitayaCluster, value)\n\nAs with single RedPitaya, but applied to all RedPitayas in a cluster.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.clearSequences!","page":"Client Library","title":"RedPitayaDAQServer.clearSequences!","text":"clearSequences!(rp::RedPitaya)\n\nInstruct the server to remove all sequences from its list. Return true if the command was successful.\n\n\n\n\n\nclearSequences!(rpc::RedPitayaCluster)\n\nAs with single RedPitaya, but applied to all RedPitayas in a cluster.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.popSequence!","page":"Client Library","title":"RedPitayaDAQServer.popSequence!","text":"popSequence!(rp::RedPitaya)\n\nInstruct the server to remove the last added sequence from its list. Return true if the command was successful.\n\n\n\n\n\n","category":"function"},{"location":"client.html#Base.length-Tuple{AbstractSequence}","page":"Client Library","title":"Base.length","text":"length(seq::AbstractSequence)\n\nReturn the number of steps a sequence will take.\n\n\n\n\n\n","category":"method"},{"location":"client.html#RedPitayaDAQServer.start","page":"Client Library","title":"RedPitayaDAQServer.start","text":"start(seq::AbstractSequence)\n\nReturn the number of steps after which a sequence leaves the ramp up phase.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.ArbitrarySequence","page":"Client Library","title":"RedPitayaDAQServer.ArbitrarySequence","text":"ArbitrarySequence <: AbstractSequence\n\nStruct representing a sequence in which the server directly takes the values from the given LUT.\n\n\n\n\n\n","category":"type"},{"location":"client.html#RedPitayaDAQServer.ArbitrarySequence-NTuple{8, Any}","page":"Client Library","title":"RedPitayaDAQServer.ArbitrarySequence","text":"ArbitrarySequence(lut, enable, stepsPerRepetition, repetitions, upSteps, upTotalSteps, downSteps, rampDownTotalSteps, reset=false)\n\nConstructor for ArbitrarySequence.\n\nArguments\n\nlut::Array{Float32}: nxm matrix containing m steps for n channel\nemable::Union{Array{Bool}, Nothing}: matrix containing enable flags\nrepetitions::Int32: the number of times the sequence should be repeated\nupSteps::Int32: the number of steps the ramping factor should be increasing to 1.0\nupTotalSteps::Int32: the total number of steps spent in the ramp up phase\ndownSteps::Int32 the number of steps the ramping factor should be decreasing to 0.0\ndownTotalSteps::Int32: the total number of steps spent in the ramp down phase\nreset::Bool: flag if the phase should be reset after this sequence is done\n\n\n\n\n\n","category":"method"},{"location":"client.html#Measurement-and-Transmission","page":"Client Library","title":"Measurement and Transmission","text":"","category":"section"},{"location":"client.html","page":"Client Library","title":"Client Library","text":"RedPitayaDAQServer.ServerMode\nRedPitayaDAQServer.serverMode\nRedPitayaDAQServer.serverMode!\nRedPitayaDAQServer.masterTrigger\nRedPitayaDAQServer.masterTrigger!\nRedPitayaDAQServer.currentWP\nRedPitayaDAQServer.currentFrame\nRedPitayaDAQServer.currentPeriod\nRedPitayaDAQServer.SampleChunk\nRedPitayaDAQServer.PerformanceData\nRedPitayaDAQServer.readPipelinedSamples\nRedPitayaDAQServer.readFrames\nRedPitayaDAQServer.convertSamplesToFrames\nRedPitayaDAQServer.calibDACOffset\nRedPitayaDAQServer.calibDACOffset!\nRedPitayaDAQServer.calibADCOffset\nRedPitayaDAQServer.calibADCOffset!\nRedPitayaDAQServer.calibADCScale\nRedPitayaDAQServer.calibADCScale!","category":"page"},{"location":"client.html#RedPitayaDAQServer.ServerMode","page":"Client Library","title":"RedPitayaDAQServer.ServerMode","text":"ServerMode\n\nRepresent the different modes the server can be in. Valid values are CONFIGURATION, MEASUREMENT and TRANSMISSION.\n\nSee also serverMode, serverMode!.\n\n\n\n\n\n","category":"type"},{"location":"client.html#RedPitayaDAQServer.serverMode","page":"Client Library","title":"RedPitayaDAQServer.serverMode","text":"serverMode(rp::RedPitaya)\n\nReturn the mode of the server.\n\nExamples\n\njulia> serverMode!(rp, MEASUREMENT);\ntrue\n\njulia> serverMode(rp)\nMEASUREMENT\n\n\n\n\n\nserverMode(rpc::RedPitayaCluster)\n\nAs with single RedPitaya, but applied to only the master.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.serverMode!","page":"Client Library","title":"RedPitayaDAQServer.serverMode!","text":"serverMode!(rp::RedPitaya, mode::ServerMode)\n\nSet the mode of the server. Valid values are \"CONFIGURATION\" and \"MEASUREMENT\".\n\nExamples\n\njulia> serverMode!(rp, MEASUREMENT);\ntrue\n\njulia> serverMode(rp)\nMEASUREMENT\n\n\n\n\n\nserverMode!(rp::RedPitaya, mode::ServerMode)\n\nSet the mode of the server.\n\nExamples\n\njulia> serverMode!(rp, MEASUREMENT);\ntrue\n\njulia> serverMode(rp)\nMEASUREMENT\n\n\n\n\n\nserverMode!(rpc::RedPitayaCluster, value)\n\nAs with single RedPitaya, but applied to all RedPitayas in a cluster.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.masterTrigger","page":"Client Library","title":"RedPitayaDAQServer.masterTrigger","text":"masterTrigger(rp::RedPitaya)\n\nDetermine whether the master trigger is set.\n\nExample\n\njulia> masterTrigger!(rp, true)\n\njulia>masterTrigger(rp)\ntrue\n\n\n\n\n\nmasterTrigger(rpc::RedPitayaCluster)\n\nAs with single RedPitaya, but applied to only the master.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.masterTrigger!","page":"Client Library","title":"RedPitayaDAQServer.masterTrigger!","text":"masterTrigger!(rp::RedPitaya, val::Bool)\n\nSet the master trigger of the RedPitaya to val. Return true if the command was successful.\n\nExample\n\njulia> masterTrigger!(rp, true)\ntrue\n\njulia>masterTrigger(rp)\ntrue\n\n\n\n\n\nmasterTrigger(rpc::RedPitayaCluster, val::Bool)\n\nSet the master trigger of the cluster to val. \n\nFor val equals to true this is the same as calling the function on the RedPitaya returned by master(rpc). If val is false then the keepAliveReset is set to true for all RedPitayas in the cluster before the master trigger is disabled. Afterwards the keepAliveReset is set to false again.\n\nSee also master, keepAliveReset!.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.currentWP","page":"Client Library","title":"RedPitayaDAQServer.currentWP","text":"currentWP(rp::RedPitaya)\n\nReturn the current writepointer of the RedPitaya.\n\n\n\n\n\ncurrentWP(rpc::RedPitayaCluster)\n\nAs with single RedPitaya, but applied to only the master.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.currentFrame","page":"Client Library","title":"RedPitayaDAQServer.currentFrame","text":"currentFrame(rp::RedPitaya)\n\nReturn the current frame of the RedPitaya based on the current writepointer, samples per period and periods per frame.\n\nSee also currentWP, samplesPerPeriod, periodsPerFrame.\n\n\n\n\n\ncurrentFrame(rpc::RedPitayaCluster)\n\nAs with single RedPitaya, but applied to only the master.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.currentPeriod","page":"Client Library","title":"RedPitayaDAQServer.currentPeriod","text":"currentPeriod(rp::RedPitaya)\n\nReturn the current period of the RedPitaya based on the current writepointer and samples per period.\n\nSee also currentWP, samplesPerPeriod.\n\n\n\n\n\ncurrentPeriod(rpc::RedPitayaCluster)\n\nAs with single RedPitaya, but applied to only the master.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.SampleChunk","page":"Client Library","title":"RedPitayaDAQServer.SampleChunk","text":"SampleChunk\n\nStruct containing a matrix of samples and associated PerformanceData\n\nFields\n\nsamples::Matrix{Int16}: nxm matrix containing m samples for n channel\nperformance::Vector{PerformanceData}: PerformanceData object for each RedPitaya that transmitted samples\n\n\n\n\n\n","category":"type"},{"location":"client.html#RedPitayaDAQServer.readPipelinedSamples","page":"Client Library","title":"RedPitayaDAQServer.readPipelinedSamples","text":"readPipelinedSamples(rpu::Union{RedPitaya,RedPitayaCluster, RedPitayaClusterView}, wpStart::Int64, numOfRequestedSamples::Int64; chunkSize::Int64 = 25000, rpInfo=nothing)\n\nRequest and receive numOfRequestedSamples samples from wpStart on in a pipelined fashion. Return a matrix of samples.\n\nIf rpInfo is set to a RPInfo, the PerformanceData sent after every chunkSize samples will be pushed into rpInfo.\n\n\n\n\n\nreadPipelinedSamples(rpu::Union{RedPitaya,RedPitayaCluster, RedPitayaClusterView}, wpStart::Int64, numOfRequestedSamples::Int64, channel::Channel; chunkSize::Int64 = 25000)\n\nRequest and receive numOfRequestedSamples samples from wpStart on in a pipelined fashion. The samples and associated PerformanceData are pushed into channel as a SampleChunk.\n\nSee SampleChunk.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.readFrames","page":"Client Library","title":"RedPitayaDAQServer.readFrames","text":"readFrames(rpu::Union{RedPitaya,RedPitayaCluster, RedPitayaClusterView}, startFrame, numFrames, numBlockAverages=1, numPeriodsPerPatch=1; rpInfo=nothing, chunkSize = 50000, useCalibration = false)\n\nRequest and receive numFrames frames from startFrame on.\n\nSee readPipelinedSamples, convertSamplesToFrames, samplesPerPeriod, periodsPerFrame, updateCalib!.\n\nArguments\n\nrpu::Union{RedPitaya,RedPitayaCluster, RedPitayaClusterView}: RedPitayas to receive samples from.\nstartFrame: frame from which to start transmitting\nnumFrames: number of frames to read\nnumBlockAverages=1: see convertSamplesToFrames\nnumPeriodsPerPatch=1: see convertSamplesToFrames\nchunkSize=50000: see readPipelinedSamples\nrpInfo=nothing: see readPipelinedSamples\nuseCalibration: convert from Int16 samples to Float32 values based on RedPitayas calibration\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.calibDACOffset","page":"Client Library","title":"RedPitayaDAQServer.calibDACOffset","text":"calibDACOffset(rp::RedPitaya, channel::Integer)\n\nRetrieve the calibration DAC offset for given channel from the RedPitayas EEPROM \n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.calibDACOffset!","page":"Client Library","title":"RedPitayaDAQServer.calibDACOffset!","text":"calibDACOffset!(rp::RedPitaya, channel::Integer, val)\n\nStore calibration DAC offset val for given channel into the RedPitayas EEPROM.  This value is used by the server to offset the output voltage. Absolute value has to be smaller than 1.0 V. \n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.calibADCOffset","page":"Client Library","title":"RedPitayaDAQServer.calibADCOffset","text":"calibADCOffset(rp::RedPitaya, channel::Integer)\n\nRetrieve the calibration ADC offset for given channel from the RedPitayas EEPROM.\n\nSee also convertSamplesToPeriods,convertSamplesToFrames.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.calibADCOffset!","page":"Client Library","title":"RedPitayaDAQServer.calibADCOffset!","text":"calibADCOffset!(rp::RedPitaya, channel::Integer, val)\n\nStore calibration ADC offset val for given channel into the RedPitayas EEPROM. Absolute value has to be smaller than 1.0 V.\n\nSee also convertSamplesToPeriods,convertSamplesToFrames.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.calibADCScale","page":"Client Library","title":"RedPitayaDAQServer.calibADCScale","text":"calibADCScale(rp::RedPitaya, channel::Integer)\n\nRetrieve the calibration ADC scale for given channel from the RedPitayas EEPROM.\n\nSee also convertSamplesToPeriods,convertSamplesToFrames.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.calibADCScale!","page":"Client Library","title":"RedPitayaDAQServer.calibADCScale!","text":"calibADCScale(rp::RedPitaya, channel::Integer)\n\nStore calibration ADC scale val for given channel into the RedPitayas EEPROM. Absolute value has to be smaller than 1.0 V.\n\nSee also convertSamplesToPeriods,convertSamplesToFrames.\n\n\n\n\n\n","category":"function"},{"location":"scpi.html#SCPI-Interface","page":"SCPI Interface","title":"SCPI Interface","text":"","category":"section"},{"location":"scpi.html","page":"SCPI Interface","title":"SCPI Interface","text":"For communication betten the server and the client an SCPI with custom commands is used. In the following tables an overview of the available commands and their behaviour is given. The Julia Client library encapsulates these commands into function calls, abstracting their communication details and also combining commands to manage a cluster of RedPitayas at the same time.","category":"page"},{"location":"scpi.html","page":"SCPI Interface","title":"SCPI Interface","text":"As a safe guard the server has different modes and certain commands are only available in certain modes. As an example, during an acquisition changing the sampling rate would result in unclear behaviour. To stop such a scenario the decimation can only be set in the CONFIGURATION mode and an acquisition can only be triggered in the ACQUISITION mode. The available modes are CONFIGURATION, ACQUISITION and TRANSMISSION. The former two are set by the client and the latter is set by the server during sample transmission.","category":"page"},{"location":"scpi.html","page":"SCPI Interface","title":"SCPI Interface","text":"After each SCPI command the server replies with true or false on the command socket depending on whether the given command was successfully excecuted. The exception to this rule are the commands which themselves just query singular values from the server which are then the only reply.","category":"page"},{"location":"scpi.html#ADC-Configuration","page":"SCPI Interface","title":"ADC Configuration","text":"","category":"section"},{"location":"scpi.html","page":"SCPI Interface","title":"SCPI Interface","text":"Command Arguments Description Mode Example\nRP:ADC:DECimation decimation value [8, ..., n] Set the decimation factor of the base sampling rate C RP:ADC:DEC 8\nRP:ADC:DECimation?  Return the decimation factor Any RP:ADC:DEC?\nRP:TRIGger:MODe trigger mode (EXTERNAL, INTERNAL) Set the trigger mode, which trigger the RedPitaya listens to C RP:TRIG:MOD INTERNAL\nRP:TRIGger:MODe?  Return the trigger mode Any RP:TRIG:MOD?\nRP:CALib:ADC:CHannel#:OFFset channel (0, 1), offset [0, ..., 1] Store the ADC offset value for given channel in EEPROM C RP:CAL:ADC:CH0:OFF 0.2\nRP:CALib:ADC:CHannel#:OFFset? channel (0, 1) Return the ADC offset value for given channel from EEPROM Any RP:CAL:ADC:CH1:OFF?\nRP:CALib:ADC:CHannel#:SCAle channel (0, 1), scale [0, ..., 1] Store the ADC scale value for given channel in EEPROM C RP:CAL:ADC:CH1:SCA 1.0\nRP:CALib:ADC:CHannel#:SCAle? channel (0, 1) Return the ADC scale value for given channel from EEPROM Any RP:CAL:ADC:CH1:SCA?","category":"page"},{"location":"scpi.html#DAC-Configuration","page":"SCPI Interface","title":"DAC Configuration","text":"","category":"section"},{"location":"scpi.html","page":"SCPI Interface","title":"SCPI Interface","text":"Command Arguments Description Mode Example\nRP:DAC:CHannel#:SIGnaltype channel (0, 1), signal type (SINE, SQUARE, TRIANGLE, SAWTOOTH) Set signal type of first component for given channel Any RP:DAC:CH0:SIG SQUARE\nRP:DAC:CHannel#:SIGnaltype? channel (0, 1) Return signal type of first component of given channel Any RP:DAC:CH1:SIG?\nRP:DAC:CHannel#:JUMPsharpness channel (0, 1)  Any \nRP:DAC:CHannel#:JUMPsharpness? channel (0, 1)  Any \nRP:DAC:CHannel#:OFFset channel (0, 1), offset [-1, ..., 1] Set offset for given channel Any RP:DAC:CH1:OFF 0.1\nRP:DAC:CHannel#:OFFset? channel (0, 1) Return offset of given channel Any RP:DAC:CH0:OFF?\nRP:DAC:CHannel#:COMPonent#:AMPlitude channel (0, 1), component (0, 1, 2, 3),  amplitude[0, ..., 1] Set amplitude of given channel and component Any \nRP:DAC:CHannel#:COMPonent#:AMPlitude? channel (0, 1), component (0, 1, 2, 3) Return amplitude of given channel and component Any \nRP:DAC:CHannel#:COMPonent#:FREQuency channel (0, 1), component (0, 1, 2, 3), frequency Set frequency of given channel and component Any \nRP:DAC:CHannel#:COMPonent#:FREQuency? channel (0, 1), component (0, 1, 2, 3) Return frequency of given channel and component Any \nRP:DAC:CHannel#:COMPonent#:PHAse channel (0, 1), component (0, 1, 2, 3), phase Set phase of given channel and component Any \nRP:DAC:CHannel#:COMPonent#:PHAse? channel (0, 1), component (0, 1, 2, 3) Return phase of given channel and component Any ","category":"page"},{"location":"scpi.html#Sequence-Configuration","page":"SCPI Interface","title":"Sequence Configuration","text":"","category":"section"},{"location":"scpi.html","page":"SCPI Interface","title":"SCPI Interface","text":"Command Arguments Description Mode Example\n    ","category":"page"},{"location":"scpi.html#Acquisition-and-Transmission","page":"SCPI Interface","title":"Acquisition and Transmission","text":"","category":"section"},{"location":"scpi.html","page":"SCPI Interface","title":"SCPI Interface","text":"Command Arguments Description Mode Example\nRP:TRIGger trigger status (OFF, ON) Set the internal trigger status M RP:TRIG ON\nRP:TRIGger?  Return the trigger status Any RP:TRIG?\nRP:TRIGger:ALiVe keep alive status (OFF, ON) Set the keep alive bypass M RP:TRIG:ALV OFF\nRP:TRIGger:ALiVe?  Return the keep alive status Any RP:TRIG:ALV?\nRP:ADC:WP:CURRent?  Return the current writepointer M, T RP:ADC:WP?\nRP:ADC:DATa? readpointer, number of samples Transmit number of samples from the buffer component of the readpointer on M RP:ADC:DATa? 400,1024\nRP:ADC:DATa:PIPElined? readpointer, number of samples, chunksize Transmit number of samples from the readpointer on in chunks of chunksize. After every chunk status and performance data is transmitted. M RP:ADC:DAT:PIPE? 400,1024,128\nRP:STATus?  Transmit status as one byte with flags from lower bits: overwritten, corrupted, lost steps, master trigger, sequence active Any RP:STAT?\nRP:STATus:OVERwritten?  Transmit overwritten flag Any RP:STAT:OVER?\nRP:STATus:CORRupted?  Transmit corrupted flag Any RP:STAT:CORR?\nRP:STATus:LOSTSteps?  Transmit lost steps flag Any RP:STAT:LOSTS?\nRP:PERF?  Transmit ADC and DAC performance data Any RP:PERF?","category":"page"},{"location":"scpi.html#DIO","page":"SCPI Interface","title":"DIO","text":"","category":"section"},{"location":"scpi.html","page":"SCPI Interface","title":"SCPI Interface","text":"Command Arguments Description Example\nRP:DIO:DIR identifier of pin, direction (IN/OUT) Set the direction of the DIO RP:DIO:DIR DIO7_P,IN\nRP:DIO identifier of pin, value (0/1) Set the output of the DIO RP:DIO DIO7_P,1\nRP:DIO? identifier of pin Get the input of the DIO RP:DIO? DIO7_P","category":"page"},{"location":"examples/producerConsumer.html#Continous-Signal-Acquisition-Example","page":"Continous Signal Acquisition","title":"Continous Signal Acquisition Example","text":"","category":"section"},{"location":"examples/producerConsumer.html","page":"Continous Signal Acquisition","title":"Continous Signal Acquisition","text":"As is mentioned in the Acquisition section, the transmission rate of the server heavily depends on the available network and the way a client processes the samples. This example shows how one can write a thread dedicated to just receiving samples and one (or more) threads dedicated to processing samples. As the example contains no visualization, there is no need for a specific RedPitaya setup.","category":"page"},{"location":"examples/producerConsumer.html#Julia-Client","page":"Continous Signal Acquisition","title":"Julia Client","text":"","category":"section"},{"location":"examples/producerConsumer.html","page":"Continous Signal Acquisition","title":"Continous Signal Acquisition","text":"This and all other examples are located in the examples directory","category":"page"},{"location":"examples/producerConsumer.html","page":"Continous Signal Acquisition","title":"Continous Signal Acquisition","text":"# Adapted from https://github.com/JuliaDocs/Documenter.jl/issues/499\nusing Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(open(f->read(f, String), \"../../../src/examples/julia/producerConsumer.jl\"))\n```\n\"\"\")","category":"page"},{"location":"devtips.html#Development-Hints","page":"Development Tips","title":"Development Hints","text":"","category":"section"},{"location":"devtips.html","page":"Development Tips","title":"Development Tips","text":"On this slide some development hints are summarized. These might change regularely if things are properly integrated into the framework.","category":"page"},{"location":"devtips.html#Alpine-Linux","page":"Development Tips","title":"Alpine Linux","text":"","category":"section"},{"location":"devtips.html","page":"Development Tips","title":"Development Tips","text":"The Alpine linux as currently a root folder with only 185.8M free space, which disallows installing more","category":"page"},{"location":"devtips.html","page":"Development Tips","title":"Development Tips","text":"applications. To change this one can do","category":"page"},{"location":"devtips.html","page":"Development Tips","title":"Development Tips","text":"mount -o remount,size=1G /","category":"page"},{"location":"devtips.html#DHCP-Server","page":"Development Tips","title":"DHCP Server","text":"","category":"section"},{"location":"devtips.html","page":"Development Tips","title":"Development Tips","text":"One possible configuration to run single or a cluster of RedPitayas is to directly connect them with the measurement computer. In case of a cluster one can use a switch such that only a single network connector is required. In case that the measurement computer has no free ethernet port one can use a USB network adapter.","category":"page"},{"location":"devtips.html","page":"Development Tips","title":"Development Tips","text":"In order to get this setup running you need to install a dhcp server and give the measurement computer a static IP address (e.g. 192.168.1.1). Then you can configure the dhcp server by modifying the configuration file /etc/dhcp/dhcpd.conf where you should create a network with a certain range (e.g. 192.168.1.100-105). You also have the opportunity to map a certain RedPitaya to a certain IP address by specifying the MAC address. You may also need to specify DNS servers.","category":"page"},{"location":"devtips.html","page":"Development Tips","title":"Development Tips","text":"The following commands are useful when you have connection problems","category":"page"},{"location":"devtips.html","page":"Development Tips","title":"Development Tips","text":"nmap -sP 192.168.1.0/24 \njournalctl -f -u isc-dhcp-server","category":"page"},{"location":"devtips.html","page":"Development Tips","title":"Development Tips","text":"If you need internet at your RedPitaya you need to configure the firewall to allow this using iptables. In this repository there is in the scripts directory a script rp-internet.sh where you need to change the network adapters to allow traffic going from the internet network adapter to the RedPitaya network adapter.","category":"page"},{"location":"examples/sequence.html#Sequence-Example","page":"Sequence","title":"Sequence Example","text":"","category":"section"},{"location":"examples/sequence.html","page":"Sequence","title":"Sequence","text":"In this example we generate a 10 kHz sine wave on DAC channel 1 and also construct a sequence with a climbing offset every 5 periods. We receive this signal on ADC channel 1. To run this example connect the RedPitaya in the following way.","category":"page"},{"location":"examples/sequence.html","page":"Sequence","title":"Sequence","text":"(Image: RedPitaya)","category":"page"},{"location":"examples/sequence.html#Julia-Client","page":"Sequence","title":"Julia Client","text":"","category":"section"},{"location":"examples/sequence.html","page":"Sequence","title":"Sequence","text":"This and all other examples are located in the examples directory","category":"page"},{"location":"examples/sequence.html","page":"Sequence","title":"Sequence","text":"# Adapted from https://github.com/JuliaDocs/Documenter.jl/issues/499\nusing Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(open(f->read(f, String), \"../../../src/examples/julia/sequence.jl\"))\n```\n\"\"\")","category":"page"},{"location":"examples/sequence.html","page":"Sequence","title":"Sequence","text":"(Image: Simple Example Results)","category":"page"},{"location":"index.html#RedPitayaDAQServer","page":"Home","title":"RedPitayaDAQServer","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Advanced DAQ Tools for the RedPitaya (STEMlab 125-14)","category":"page"},{"location":"index.html#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This project contains software to be used with the STEMlab 125-14 device from RedPitaya. It allows for continuous generation and measurement of signals with up to 15.625 MS/s, which is not possible with the standard image of the RedPitaya. In addition, the software allows to synchronize a cluster of multiple RedPitayas. This project contains the following parts:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Alpine Linux image for the RedPitaya\nFPGA image\nLibrary written in C to interact with the FPGA image on the RedPitaya\nSCPI Server for accessing the functionality over TCP/IP\nSCPI Client to access the server","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The code repositories is contained in this repository.","category":"page"},{"location":"index.html#License-/-Terms-of-Usage","page":"Home","title":"License / Terms of Usage","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The source code of this project is licensed under the MIT license. This implies that you are free to use, share, and adapt it. However, please give appropriate credit by citing the project.","category":"page"},{"location":"index.html#Contact","page":"Home","title":"Contact","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"If you have problems using the software, find mistakes, or have general questions please use the issue tracker to contact us.","category":"page"},{"location":"index.html#Contributors","page":"Home","title":"Contributors","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Tobias Knopp\nNiklas Hackelberg\nJonas Schumacher\nMatthias Gräser","category":"page"},{"location":"index.html#Credit","page":"Home","title":"Credit","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This package is partly based on work of Koheron [1] and Pavel Demin [2]","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"[1] https://www.koheron.com/blog/2016/11/29/red-pitaya-cluster [2] https://github.com/pavel-demin/red-pitaya-notes","category":"page"}]
}
