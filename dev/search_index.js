var documenterSearchIndex = {"docs":
[{"location":"generation.html#Signal-Generation","page":"Signal Generation","title":"Signal Generation","text":"","category":"section"},{"location":"generation.html","page":"Signal Generation","title":"Signal Generation","text":"Once the acquisition is triggered, each RedPitaya also starts producing signals on their output channels. Each RedPitaya features six such channels, two of those are the 16-bit DAC channel and four of those are digital pins using PDM, see Connections. The output signals are composed of three parts: parameterized waveforms W_i(t), an offset o_i and repeating arbitrary LUT tables. The latter are called sequences seq_i(t). The resulting signal of the DAC channel can be described as: ","category":"page"},{"location":"generation.html","page":"Signal Generation","title":"Signal Generation","text":"S_i(t) = seq_i(t) + o_i + W_i(t)","category":"page"},{"location":"generation.html#Waveforms","page":"Signal Generation","title":"Waveforms","text":"","category":"section"},{"location":"generation.html","page":"Signal Generation","title":"Signal Generation","text":"Each of the 16-bit DAC channel can output a compositve waveform with four components. Each component can be parametrized by its amplitude a_ij, frequency f_ij and phase varphi_ij, which can all be changed via SCPI commands. Furthermore, each component also offers different waveforms w_ij(sine, triangle, sawtooth):","category":"page"},{"location":"generation.html","page":"Signal Generation","title":"Signal Generation","text":"W_i(t) = sum_j=1^4a_ij w_ij(2pi f_ijt + varphi_i j)","category":"page"},{"location":"generation.html#Ramping","page":"Signal Generation","title":"Ramping","text":"","category":"section"},{"location":"generation.html","page":"Signal Generation","title":"Signal Generation","text":"The signals output on the DAC channel can also be multiplied with an increasing/decreasing ramping factor r(t). Ramping and the ramping duration can be enabled and set on a per channel basis. The increasing factor starts from 0 and goes to 1 from the acquisition start on. The decreasing factor goes from 1 to 0.","category":"page"},{"location":"generation.html","page":"Signal Generation","title":"Signal Generation","text":"S_i(t) = r(t)S(t)","category":"page"},{"location":"generation.html","page":"Signal Generation","title":"Signal Generation","text":"The ramp down has to be started either by a SCPI command or by a flag from a sequence. Disabling the acquisition trigger removes the ramp down flag, but not the flag that enables ramping itself.","category":"page"},{"location":"generation.html#Sequences","page":"Signal Generation","title":"Sequences","text":"","category":"section"},{"location":"generation.html","page":"Signal Generation","title":"Signal Generation","text":"The FPGA image features a LUT containing values for all output channels. This LUT is treated as a ring-buffer through which the image iterates and outputs the values on their respective channel. The image can be configured to increment its LUT access every n samples. One period of a value is also called a step. A sequence is a series of steps and the number of times this series is to be repeated.","category":"page"},{"location":"generation.html","page":"Signal Generation","title":"Signal Generation","text":"As the LUT used by the FPGA image is small in comparison with the main memory and in order to support longer series of steps, the server itselfs maintains a sequence in its main memory and periodically reads the next steps from its sequence and writes them to the LUT of the image.","category":"page"},{"location":"generation.html","page":"Signal Generation","title":"Signal Generation","text":"Comparable to the sample transmission of the acquisition, this updating of the LUT is also a process with timing uncertainty as it is affected by the scheduling and execution of the RedPitayas CPU. While during the sample transmission samples could be lost because they were overwritten, in the signal generation wrong signals could be output because the server was too slow in updating the values. Here, the server tracks similar performance metrics and also features a status flag lostSteps for exactly this case. In its current implementation a safe step rate is at 12 kHz.","category":"page"},{"location":"generation.html","page":"Signal Generation","title":"Signal Generation","text":"Sequences and their steps also have additional features. A step can be marked such that during its duration the signal is set to 0. Furthermore, a step can be marked such that it triggers the ramp down. To make this easier to manage the server actually manages three sequences, that can be set individually: A ramp up, regular and ramp down sequence. The ramp up sequence is moved to the FPGA LUT at the acquisition start, followed by the regular sequence. Afterwards the ramp down sequence is started and during its execution the ramp down flag is set.","category":"page"},{"location":"generation.html#Calibration","page":"Signal Generation","title":"Calibration","text":"","category":"section"},{"location":"generation.html","page":"Signal Generation","title":"Signal Generation","text":"Similar to the signal acqusition, there are also calibration scale c_i scale and offset c_i offset values  for the signal generation. These are stored in the EEPROM of the RedPitaya and can be updated by a client. The calibration values are always applied, even when the master trigger is off.","category":"page"},{"location":"generation.html","page":"Signal Generation","title":"Signal Generation","text":"Thus the total signal can be described as:","category":"page"},{"location":"generation.html","page":"Signal Generation","title":"Signal Generation","text":"S_i(t) = c_i scale S_i(t) + c_i offset","category":"page"},{"location":"connections.html#Connections","page":"Connections","title":"Connections","text":"","category":"section"},{"location":"connections.html","page":"Connections","title":"Connections","text":"An overview of the extension connectors (see also here) is given in the following image","category":"page"},{"location":"connections.html","page":"Connections","title":"Connections","text":"(Image: Connectors)","category":"page"},{"location":"connections.html","page":"Connections","title":"Connections","text":"The project uses most but not all connections that are used in the original RedPitaya image. From the connector E2 only the analog inputs and outputs are used. From the connector E1 several pins are reserved for the following purposes:","category":"page"},{"location":"connections.html","page":"Connections","title":"Connections","text":"DIO0_P for the ADC and DAC trigger. Connect it with the master's DIO5_P to distribute the trigger signal to all RedPitayas in a cluster. As long as the input is high, the DACs and ADCs are running.\nDIO1_P is the input for the watchdog (see configuration register section for further details)\nDIO2_P is used to acknowledge a received watchdog signal.\nDIO3_P can be set to high, to stop all DACs instantly.\nDIO4_P outputs a high for 10 ms after a 100 ms pause on low to provide an alive signal.\nDIO5_P can be set to high via the configuration register to provide the mutual trigger signal.\nDIO7_P, DIO7_N, DIO6_P, DIO6_N, DIO5_N, DIO4_N, DIO3_N, DIO2_N can be used as arbitrary outputs set via the server.\nDIO0_N and DIO1_N are used for the clock selection in a cluster.","category":"page"},{"location":"examples/cluster.html#Cluster-Example","page":"Cluster","title":"Cluster Example","text":"","category":"section"},{"location":"examples/cluster.html","page":"Cluster","title":"Cluster","text":"In this example we generate and acquire sine waves, similar to to the first example. However, this time we use two RedPitayas sychronized in a cluster. The example will create a sine wave on the first DAC channel of the first RedPitaya and a phase shifted sine wave on the first channel of the second RedPitaya. To run this example connect the RedPitayas in the following way:","category":"page"},{"location":"examples/cluster.html","page":"Cluster","title":"Cluster","text":"(Image: RedPitaya)","category":"page"},{"location":"examples/cluster.html","page":"Cluster","title":"Cluster","text":"Note that while the example only plots the first channel of the RedPitaya, both channels are transmitted to the clients.","category":"page"},{"location":"examples/cluster.html#Julia-Client","page":"Cluster","title":"Julia Client","text":"","category":"section"},{"location":"examples/cluster.html","page":"Cluster","title":"Cluster","text":"This and all other examples are located in the examples directory","category":"page"},{"location":"examples/cluster.html","page":"Cluster","title":"Cluster","text":"# Adapted from https://github.com/JuliaDocs/Documenter.jl/issues/499\nusing Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(open(f->read(f, String), \"../../../src/examples/julia/cluster.jl\"))\n```\n\"\"\")","category":"page"},{"location":"examples/sequenceMultiChannel.html#Sequence-Multi-Channel-and-Waveform-Enable-Example","page":"Sequence Multi-Channel and Waveform Enable","title":"Sequence Multi-Channel and Waveform Enable Example","text":"","category":"section"},{"location":"examples/sequenceMultiChannel.html","page":"Sequence Multi-Channel and Waveform Enable","title":"Sequence Multi-Channel and Waveform Enable","text":"This examples combines concepts from the three examples and additionally uses the signal enable feature of the sequences. This example uses both DAC and ADC channels of the RedPitaya. On the first DAC channel we output a sine waveform together with a climbing sequence. On the second channel we output just a sequence with a constant value and no waveforms at all. The signal enable flags of the sequences are set in such a way, that the two channels alternate being enabled with each step.","category":"page"},{"location":"examples/sequenceMultiChannel.html","page":"Sequence Multi-Channel and Waveform Enable","title":"Sequence Multi-Channel and Waveform Enable","text":"(Image: RedPitaya)","category":"page"},{"location":"examples/sequenceMultiChannel.html#Julia-Client","page":"Sequence Multi-Channel and Waveform Enable","title":"Julia Client","text":"","category":"section"},{"location":"examples/sequenceMultiChannel.html","page":"Sequence Multi-Channel and Waveform Enable","title":"Sequence Multi-Channel and Waveform Enable","text":"This and all other examples are located in the examples directory","category":"page"},{"location":"examples/sequenceMultiChannel.html","page":"Sequence Multi-Channel and Waveform Enable","title":"Sequence Multi-Channel and Waveform Enable","text":"# Adapted from https://github.com/JuliaDocs/Documenter.jl/issues/499\nusing Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(open(f->read(f, String), \"../../../src/examples/julia/sequence.jl\"))\n```\n\"\"\")","category":"page"},{"location":"examples/sequenceMultiChannel.html","page":"Sequence Multi-Channel and Waveform Enable","title":"Sequence Multi-Channel and Waveform Enable","text":"(Image: Simple Example Results)","category":"page"},{"location":"installation.html#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation.html","page":"Installation","title":"Installation","text":"The RedPitayaDAQServer project uses a custom RedPitaya image that was derived from the red-pitaya-notes project. It consists of an Alpine Linux with some development tools installed, as well as the server and the FPGA images. The Linux image reserves the upper 128 MB of main memory for the FPGA, which is used as a buffer for recording the data from the ADCs. The latest releases of the project can be downloaded here.","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"To install the project on a RedPitaya, format an SD card in FAT32 and enable the bootable flag. On Linux this can be done with:","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"sudo fdisk /dev/sdb","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"on the correct device. In the prompt create a new partition with n and change its type to FAT32 with the t command and the hex code b. With the command a the bootable flag can be toggled. Finish formatting with the w command.","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"Afterwards a file system can be created with:","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"sudo mkfs -t vfat /dev/sdb1","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"To finish installing the RedPitaya, simply unzip one of the releases and copy the files into the now empty and formatted SD card.","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"When the RedPitaya is now booted, the server should start. One can then use a client to connect, at which point the FPGA image is loaded. ","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"The client library provided with the project is not an executable program, but it can be used to implement one. The library encapsulates the communication with the server and implements various optimizations. As the communication with the server is language agnostic one could therefore implement their own client in a different language. The Julia reference client library found in src/client/julia, the SCPI commands and the sections on the signal acquisition and generation are starting points for such a custom client.","category":"page"},{"location":"installation.html#Julia-Client","page":"Installation","title":"Julia Client","text":"","category":"section"},{"location":"installation.html","page":"Installation","title":"Installation","text":"To use the provided Julia client library you need to install RedPitayaDAQServer Julia package within Julia. To this end  download Julia 1.5 or later and go into the package manager mode by intering ]. Then with ","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"add RedPitayaDAQServer","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"the latest release of the Julia client is added. To install a different version, please consult the Pkg documentation. The Julia client and the RedPitaya image should be from the same release to avoid errors due to communication protocol changes.","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"To try out the Julia examples one can either download them from Github directly, clone the whole repository or use the alternative way of installing Julia packages described here.","category":"page"},{"location":"installation.html#Updating","page":"Installation","title":"Updating","text":"","category":"section"},{"location":"installation.html","page":"Installation","title":"Installation","text":"The Julia client offers function to automatically update the server and FPGA of a RedPitaya. More on this can be found here. Note that this process deletes all data in the RedPitayaDAQServer folder on the RedPitaya.","category":"page"},{"location":"installation.html#Network-Connection","page":"Installation","title":"Network Connection","text":"","category":"section"},{"location":"installation.html","page":"Installation","title":"Installation","text":"The system as provided here should not be made accessible from the internet since it uses a default public password and ssh-key.","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"One possible configuration to run single or a cluster of RedPitayas is to directly connect them with the measurement computer. In case of a cluster one can use a switch such that only a single network connector is required. In case that the measurement computer has no free ethernet port one can use a USB network adapter.","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"In order to get this setup running you need to install a dhcp server on the measurement computer, such as dhcpd, and give the measurement computer a static IP address (e.g. 192.168.1.1). This can be installed with ","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"sudo apt-get install isc-dhcp-server","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"One can then edit the /etc/dhcp/dhcpd.conf configuration file with a setup similar to the following example:","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"subnet 192.168.1.0 netmask 255.255.255.0 {\n        interface ????;\n\n        #range dynamic-bootp 192.168.1.100 192.168.1.102;\n        option broadcast-address 192.168.1.255;\n        option routers 192.168.1.1;\n\n        host rp1 {\n                hardware ethernet 00:26:32:F0:70:83;\n                fixed-address 192.168.1.100;\n        }\n\n        host rp2 {\n                hardware ethernet 00:26:32:F0:92:97;\n                fixed-address 192.168.1.101;\n        }\n\n        host rp3 {\n                hardware ethernet 00:26:32:F0:61:F5;\n                fixed-address 192.168.1.102;\n        }\n}","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"The example defines three fixed IP addresses for three RedPitayas based on their MAC addresses. You may also need to specify DNS servers or alternatively create a network with a range of IPs (e.g. 192.168.1.100-105).","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"Afterwards with","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"service isc-dhcp-server start","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"or ","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"service isc-dhcp-server restart ","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"one can start the DHCP service and should see the RedPitayas using the DHCP protocol to get their IP addresses with:","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"journalctl -f -u isc-dhcp-server","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"This displays the latest log messages of the DHCP service. ","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"If you need internet at your RedPitaya you need to configure the firewall to allow this using iptables. In this repository there is in the scripts directory a script rp-internet.sh where you need to change the network adapters to allow traffic going from the internet network adapter to the RedPitaya network adapter.","category":"page"},{"location":"installation.html#Building-Components","page":"Installation","title":"Building Components","text":"","category":"section"},{"location":"installation.html#Linux-Image-and-FPGA-Images","page":"Installation","title":"Linux Image and FPGA Images","text":"","category":"section"},{"location":"installation.html","page":"Installation","title":"Installation","text":"If you want to build the Linux image or the FPGA bitfiles yourself, you can install Xilinx Vitis and Vivado (2021.2) in an Ubuntu environment (bare metal or virtual machine). Then run","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"sudo apt-get update\n\nsudo apt-get --no-install-recommends install \\\n  build-essential bison flex git curl ca-certificates sudo \\\n  xvfb fontconfig libxrender1 libxtst6 libxi6 make \\\n  bc u-boot-tools device-tree-compiler libncurses5-dev \\\n  libssl-dev qemu-user-static binfmt-support zip \\\n  squashfs-tools dosfstools parted debootstrap zerofree","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"in order to get the essential tools. Afterwards clone the project with","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"git clone https://github.com/tknopp/RedPitayaDAQServer","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"Then switch into this directory. You can build the whole project using","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"make all","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"With ","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"make daq_bitfiles","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"one can build both the 7010 and the 7020 versions of the FPGA image. For different build targets consult the Makefiles.","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"Note: make has to be run as root if you want to build the Linux image, since chroot requires root privileges.","category":"page"},{"location":"installation.html#Server","page":"Installation","title":"Server","text":"","category":"section"},{"location":"installation.html","page":"Installation","title":"Installation","text":"To build the RedPitaya server connect the RedPitaya to your local network and access the device via ssh:","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"ssh root@rp-f?????.local","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"where ????? is the ID that is printed on the RedPitaya. The default password is root. After logging into the RedPitaya go to the folder","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"/root/apps/","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"and clone the RedPitayaDAQServer project if it does not exist already:","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"git clone https://github.com/tknopp/RedPitayaDAQServer","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"Sometimes you might need to make the file system writable by entering","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"mount -o remount,rw /dev/mmcblk0p1","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"Then cd into RedPitayaDAQServer","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"cd /root/apps/RedPitayaDAQServer","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"and enter make server. This will compile the library, the server, and some example applications. After you restart the RedPitaya the DAQ server will automatically run and you can access it via TCP.","category":"page"},{"location":"installation.html#Developing-Julia-Client-Library","page":"Installation","title":"Developing Julia Client Library","text":"","category":"section"},{"location":"installation.html","page":"Installation","title":"Installation","text":"Another option when installing the Julia client is to add the package with the  dev command:","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"dev RedPitayaDAQServer","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"in the package mode ].","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"This installs the package in development mode and puts the files into ~/.julia/dev/RedPitayaDAQServer/. There you can the also modify the files, which is handy when trying out the examples. You need to manually git pull if you want to get updates, i.e. Julia will not update developed packages automatically.","category":"page"},{"location":"examples/waveforms.html#Waveforms-Example","page":"Waveforms","title":"Waveforms Example","text":"","category":"section"},{"location":"examples/waveforms.html","page":"Waveforms","title":"Waveforms","text":"In this example we generate different signals with a base frequency of 10 kHz on DAC channel 1 and receive the same signals on the ADC channel 1. To run this example connect the RedPitaya in the following way.","category":"page"},{"location":"examples/waveforms.html","page":"Waveforms","title":"Waveforms","text":"(Image: RedPitaya)","category":"page"},{"location":"examples/waveforms.html","page":"Waveforms","title":"Waveforms","text":"It is also possible to update the signal type during the acquisition without going back to the CONFIGURATION mode.","category":"page"},{"location":"examples/waveforms.html#Julia-Client","page":"Waveforms","title":"Julia Client","text":"","category":"section"},{"location":"examples/waveforms.html","page":"Waveforms","title":"Waveforms","text":"This and all other examples are located in the examples directory","category":"page"},{"location":"examples/waveforms.html","page":"Waveforms","title":"Waveforms","text":"# Adapted from https://github.com/JuliaDocs/Documenter.jl/issues/499\nusing Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(open(f->read(f, String), \"../../../src/examples/julia/waveforms.jl\"))\n```\n\"\"\")","category":"page"},{"location":"examples/waveforms.html","page":"Waveforms","title":"Waveforms","text":"(Image: Simple Example Results)","category":"page"},{"location":"examples/batch.html#Batch-Example","page":"Batch","title":"Batch Example","text":"","category":"section"},{"location":"examples/batch.html","page":"Batch","title":"Batch","text":"In this example we recreate the first example using the batch functionality offered by the Julia client. Note that all commands are still executed in order from the RedPitayas perspective, only the client communication is more efficient within a batch.","category":"page"},{"location":"examples/batch.html","page":"Batch","title":"Batch","text":"To run this example connect the RedPitaya in the following way.","category":"page"},{"location":"examples/batch.html","page":"Batch","title":"Batch","text":"(Image: RedPitaya)","category":"page"},{"location":"examples/batch.html","page":"Batch","title":"Batch","text":"It is also possible to update the signal type during the acquisition without going back to the CONFIGURATION mode.","category":"page"},{"location":"examples/batch.html#Julia-Client","page":"Batch","title":"Julia Client","text":"","category":"section"},{"location":"examples/batch.html","page":"Batch","title":"Batch","text":"This and all other examples are located in the examples directory","category":"page"},{"location":"examples/batch.html","page":"Batch","title":"Batch","text":"# Adapted from https://github.com/JuliaDocs/Documenter.jl/issues/499\nusing Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(open(f->read(f, String), \"../../../src/examples/julia/batch.jl\"))\n```\n\"\"\")","category":"page"},{"location":"examples/batch.html","page":"Batch","title":"Batch","text":"(Image: Batch Example Results)","category":"page"},{"location":"examples/simple.html#Simple-Example","page":"Simple","title":"Simple Example","text":"","category":"section"},{"location":"examples/simple.html","page":"Simple","title":"Simple","text":"In the first example we connect to a single RedPitaya and generate a sinus signal of frequency 10 kHz on DAC channel 1 and receive the same signal on the ADC channel 1. To run this example connect the RedPitaya in the following way.","category":"page"},{"location":"examples/simple.html","page":"Simple","title":"Simple","text":"(Image: RedPitaya)","category":"page"},{"location":"examples/simple.html","page":"Simple","title":"Simple","text":"Note that while the example only plots the first channel of the RedPitaya, both channels are transmitted to the clients.","category":"page"},{"location":"examples/simple.html#Julia-Client","page":"Simple","title":"Julia Client","text":"","category":"section"},{"location":"examples/simple.html","page":"Simple","title":"Simple","text":"This and all other examples are located in the examples directory.","category":"page"},{"location":"examples/simple.html","page":"Simple","title":"Simple","text":"# Adapted from https://github.com/JuliaDocs/Documenter.jl/issues/499\nusing Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(open(f->read(f, String), \"../../../src/examples/julia/simple.jl\"))\n```\n\"\"\")","category":"page"},{"location":"examples/simple.html","page":"Simple","title":"Simple","text":"(Image: Simple Example Results)","category":"page"},{"location":"examples/simple.html#Python-Client","page":"Simple","title":"Python Client","text":"","category":"section"},{"location":"examples/simple.html","page":"Simple","title":"Simple","text":"This example is located in the python examples directory. The python examples use a very reduced Python client class that is located here. The Python client only wraps the low-level socket communication.","category":"page"},{"location":"examples/simple.html","page":"Simple","title":"Simple","text":"using Markdown\nMarkdown.parse(\"\"\"\n```python\n$(open(f->read(f, String), \"../../../src/examples/python/simple.py\"))\n```\n\"\"\")","category":"page"},{"location":"architecture.html#Architecture","page":"Architecture","title":"Architecture","text":"","category":"section"},{"location":"architecture.html","page":"Architecture","title":"Architecture","text":"The RedPitayaDAQServer project is implemented as a distributed system in which one client connects to a cluster of RedPitaya boards. The project has four software components:","category":"page"},{"location":"architecture.html","page":"Architecture","title":"Architecture","text":"FPGA image running on the RedPitayas FPGA\nC library encapsulating access to the FPGA image\nServer running on the CPU of the RedPitayas\nClient Julia reference library ","category":"page"},{"location":"architecture.html","page":"Architecture","title":"Architecture","text":"The FPGA image is responsible for generating and acquiring synchronized out- and input signals. The server acts as an intermediary to the FPGA over a TCP/IP connection, which allows remote clients to configure the FPGA image and retrieve samples. Furthermore, the server also maintains a thread that takes part in signal generation.","category":"page"},{"location":"architecture.html","page":"Architecture","title":"Architecture","text":"The Julia client library can be used to implement a data acquisition client application, which controls a (cluster of) RedPitaya(s). This Julia library acts as a reference, but in principle it is possible to write clients in any programming language, as the communication is language agnostic. In the example directory we provide a rudimentary Python client that allows to perform a simple data acquisition experiment.","category":"page"},{"location":"architecture.html#Communication","page":"Architecture","title":"Communication","text":"","category":"section"},{"location":"architecture.html","page":"Architecture","title":"Architecture","text":"The various components of the distributed system communicate over different interfaces. Communication within a RedPitaya is based on memory-mapped I/O, while communication between the server and a client is based on SCPI commands over a TCP/IP connection, usually over Ethernet. Lastly communication between RedPitayas is limited to signals distributed over cables as described in Cluster.","category":"page"},{"location":"architecture.html#FPGA-and-CPU","page":"Architecture","title":"FPGA and CPU","text":"","category":"section"},{"location":"architecture.html","page":"Architecture","title":"Architecture","text":"The FPGA image is directly connected to certain memory regions that can be memory mapped on the CPU side of the RedPitaya. Both the CPU and the FPGA image access the reserved main memory region as a sample buffer. The C library rp-daq-lib, which is located under src/lib/ in the project repository, encapsulates these memory accesses into a convenient C library. It is possible to use this C library directly on the RedPitaya when no communication with the host system is required, i.e. if one wants to write the acquired data into a file. When making changes to the FPGA image one may need to adapt the rp-daq-lib C library.","category":"page"},{"location":"architecture.html","page":"Architecture","title":"Architecture","text":"The server itself uses the rp-daq-lib library to interface with the FPGA image.","category":"page"},{"location":"architecture.html#Client-and-Server","page":"Architecture","title":"Client and Server","text":"","category":"section"},{"location":"architecture.html","page":"Architecture","title":"Architecture","text":"The server on each RedPitaya has two TCP sockets to which a client needs to connect. The first is the command socket on port 5025 and the second is the data socket on port 5026. Over the former, a client can send SCPI commands to the server and receive replies, while the latter is used for sending binary data such as the samples acquired by the ADCs.","category":"page"},{"location":"architecture.html","page":"Architecture","title":"Architecture","text":"SCPI commands are ASCII strings, such as RP:ADC:DECimation, which the server translates into C function calls. As an example these calls could invoke a function of the rp-daq-lib library to set the decimation of the sampling rate or instruct the server to transmit data over the data socket. A list of the available SCPI commands can be found here.","category":"page"},{"location":"architecture.html","page":"Architecture","title":"Architecture","text":"At any point a server is only connected to one client and establishing a new connection stops any current signal generation and acquisition.","category":"page"},{"location":"fpga.html#FPGA-Development","page":"FPGA Development","title":"FPGA Development","text":"","category":"section"},{"location":"fpga.html","page":"FPGA Development","title":"FPGA Development","text":"There may be needs to change the FPGA image. The following explains how this can be done.","category":"page"},{"location":"fpga.html#Preparation","page":"FPGA Development","title":"Preparation","text":"","category":"section"},{"location":"fpga.html","page":"FPGA Development","title":"FPGA Development","text":"If you want to make changes to the FPGA design, you need to install Vivado 2021.2. More infos for setting up a development machine we refer to the following resource and here.","category":"page"},{"location":"fpga.html","page":"FPGA Development","title":"FPGA Development","text":"After following the installation steps, you need to clone the repository into a directory of your choice and then regenerate the IP cores and the project by running","category":"page"},{"location":"fpga.html","page":"FPGA Development","title":"FPGA Development","text":"make daq_bitfiles.","category":"page"},{"location":"fpga.html","page":"FPGA Development","title":"FPGA Development","text":"Afterwards you can start Vivado and open the recreated project in ./build/fpga/<xc7z010clg400-1,xc7z020clg400-1>/firmware/RedPitayaDAQServer.xpr. Apply the changes you need and then create the bitfile by using 'Flow -> Generate Bitstream'. This runs the synthesis and implementation steps and output the Bitfile to ./build/fpga/firmware/RedPitayaDAQServer.runs/impl_1/system_wrapper.bit.","category":"page"},{"location":"fpga.html","page":"FPGA Development","title":"FPGA Development","text":"After creating the respective bitfile you need to copy it to your Red Pitayas. You can use","category":"page"},{"location":"fpga.html","page":"FPGA Development","title":"FPGA Development","text":"scp ./build/fpga/<xc7z010clg400-1,xc7z020clg400-1>/firmware/RedPitayaDAQServer.runs/impl_1/system_wrapper.bin root@<IP>:/root/RedPitayaDAQServer/bitfiles/daq_<xc7z010clg400-1,xc7z020clg400-1>.bin","category":"page"},{"location":"fpga.html","page":"FPGA Development","title":"FPGA Development","text":"for this. Set your IP and FPGA version accordingly. Another option is to fully regenerate the Linux image with make all and copy it to the SD card.","category":"page"},{"location":"fpga.html","page":"FPGA Development","title":"FPGA Development","text":"Since using git with Vivado can be annoying here are some hints how you can make your changes ready for git:","category":"page"},{"location":"fpga.html","page":"FPGA Development","title":"FPGA Development","text":"If you only changed some stuff in the blockdesign, you just have to export the blockdesign to ./src/fpga/bd/bd.tcl by using 'File -> Export -> Export Block Design' in Vivado.\nChanges to the project settings have to be done in ./src/fpga/build.tcl in order to not lose the ability to recreate your changed project.\nFor your own IP cores, just create a new directory in ./src/fpga/cores and copy and adapt the core_config.tcl of another core. Afterwards re-run make cores.","category":"page"},{"location":"acquisition.html#Data-Acqusition","page":"Data Acquisition","title":"Data Acqusition","text":"","category":"section"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"The data acqusition of the RedPitayaDAQServer project is based on two data flows to and from the upper 128 MB of the RedPitaya memory. This memory region acts as a ring buffer for the acquired samples and can be queried by clients using SCPI commands.","category":"page"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"Signal acquisition within a cluster is based on a shared clock and trigger signal distributed via cables between the RedPitayas. Once triggered, all FPGAs continuously write the samples from their ADC channel to the sample ring-buffer with each clock tick. Both ADC channels on a RedPitaya are written to the buffer at the same time. The 14-bit values of the ADCs are converted to 16-bit signed integer samples and then concatenated into one 32-bit value, which is then written to the buffer. The sampling rate of the system can be adjusted by setting a decimation parameter and the decimation itself is realized with a CIC filter.","category":"page"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"Internally, the FPGA keeps track of a 64-bit writepointer register pointing into the ring-buffer and increments this value with each new sample pair. Additionally, the writepointer also counts the number of buffer overflows. As the size of the buffer region is a power of two, these two components of the writepointer can be interpreted as one 64-bit number counting the samples from acquisition start. For the 128 MB buffer, this means that the lower 25 bits of the writepointer are the buffer location and the remaining bits are the overflow counter.","category":"page"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"As the writepointer is reset and incremented based on a shared clock and trigger signal, it is synchronized across all FPGA images in a cluster. The logic implemented with the reprogrammable hardware is also the only logic of the RedPitayaDAQServer with predictable timing behaviour. All other components of the system implement their (timing related) logic in reference to the current writepointer values. With a known sampling rate, the writepointer can also be seen as the clock of the server and client components.","category":"page"},{"location":"acquisition.html#Sample-Transmission","page":"Data Acquisition","title":"Sample Transmission","text":"","category":"section"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"To retrieve samples from the server a client can supply a similar pointer, called readpointer, together with the number of samples to retrieve. The server then extracts the buffer position from the readpointer and transmits the requested amount of samples over the data socket. This transmission happens either way, even if the samples are overwritten. However, the server uses the whole readpointer, including the buffer overflows, to check if the requested samples were overwritten.","category":"page"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"If the distance between the write- and readpointer is larger than the buffer size the overflow status flag is set. If during the transmission the requested samples are overwritten the corrupted flag is set. These flags can be queried individually or together in a status byte via SCPI commands.","category":"page"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"This distance can not only be used to see if samples were overwritten, but also to track how well the client is able to keep up with the FPGA during a series of sample transmissions. If this distance increases over time, the FPGA is creating more samples than the server can transmit to the client. To allow a client to track this value, this distance is stored as a 64-bit value deltaRead for the latest transmission and can be queried. Additionally, the server also tracks the duration of the transmission as writepointer \"clock ticks\" as a 64-bit value deltaSend, which is just the difference between the writepointer at the start and end of a transmission.","category":"page"},{"location":"acquisition.html#Considerations-for-Sample-Transmission","page":"Data Acquisition","title":"Considerations for Sample Transmission","text":"","category":"section"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"There are several things to consider when attempting to retrieve samples at a high sampling rate, for larger cluster sizes or for longer periods of time. Most of the following points were implemented/considered in the Julia reference implementation, but would become relevant when implementing custom clients.","category":"page"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"As the server will always transmit samples just based on the buffer position of a readpointer, if a client wants to only receive certain samples it needs to wait for them to exist in the buffer. This requires querying the writepointer until it is larger than the desired readpointer.","category":"page"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"If the number of requested samples is larger than the buffer, the sample should be requested in smaller chunks as the server would otherwise return samples that were not written yet. In a cluster scenario the i-th chunk should be requested from all RedPitayas in the cluster before requesting the next chunk to avoid \"starvation\" effects.","category":"page"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"The status and performance data of a transmission can only be queried after the transmission has finished, which requires additionaly communication overhead.","category":"page"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"To help clients with these issues, the server offers a second type of sample transmission in which samples, status and performance data is pipelined. In such a query a client first transmits a readpointer, together with the number of requested samples and the number of samples belonging to a chunk. The server itself then tracks the writepointer and transmits a chunk as soon as it becomes available and immidiatey follows that up with the status and performance data of the transmission. This way additional communication overheard is reduced and after the inital request a client just needs to read data until the transmission finishes.","category":"page"},{"location":"acquisition.html#Frames,-Periods-and-Voltage","page":"Data Acquisition","title":"Frames, Periods and Voltage","text":"","category":"section"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"The samples sent by the server are the 16-bit values of the ADC channel of a RedPitaya. However, one might want to work with voltage values instead or encapsulate samples into a repeating concept like frames. The Julia client library offers functions to convert samples into such a concept or to directly request a number of frames instead of a number of samples.","category":"page"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"Here, frames are comprised of periods, which in turn are comprised of samples. During the conversion process the 16-bit binary values can also be converted to floating point numbers representing a voltage if the RedPitaya was calibrated beforehand. In this calibration process, a client can store scale and offset values for each channel in the EEPROM of the RedPitaya. When the client establishes a connection to the server, it reads these values and can use them to translate the 16-bit values into a respective voltage value.","category":"page"},{"location":"acquisition.html#Sampling-and-Data-Rates,-Transmission-Speeds-and-Time-to-Live","page":"Data Acquisition","title":"Sampling and Data Rates, Transmission Speeds and Time-to-Live","text":"","category":"section"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"The highest supported sampling rate of the RedPitayaDAQServer is 15.625 MHz or 15.625 MS/s, as this is the sampling rate at which a single RedPitaya can produce and transmit samples continously without data loss given the 1 Gbit/s limit of the ethernet connection from the RedPitaya. This rate is a achieved with a decimation of 8 from the base 125 MHz sampling rate of the RedPitaya hardware.","category":"page"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"At this sampling rate a single RedPitaya produces new samples at a data rate of 500 Mbit/s. Furthermore at this rate, once a sample has been written to the buffer it exists for 2.15s before being overwritten again (Time-To-Live, TTL). An overview of these metrics for different decimation factors is shown in the following table:","category":"page"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"Decimation MHz MByte/s Mbit/s TTL\n64 1.95 7.81 62.5 17.18s\n32 3.91 15.63 125 8.59s\n16 7.81 31.25 250 4.29s\n8 15.63 62.5 500 2.15s","category":"page"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"The table only refers to the data rate of new samples being produced. The data rate of samples being transmitted to a client can differ greatly depending on how the client queries and processes the samples and the available network bandwidth and usage. At the higher sampling rates it is recommended to have client threads that exclusively receive samples and perform any computation on samples in different threads to maximise the transmission speed, as a server can only transmit data at a rate of just above 500 Mbit/s. This exceeds the highest supported sampling rate by only a few Mbit/s and a client with frequency interruptions of its sample reception might not be able to keep up with the sampling rate.","category":"page"},{"location":"examples/ramping.html#Ramping-Example","page":"Ramping","title":"Ramping Example","text":"","category":"section"},{"location":"examples/ramping.html","page":"Ramping","title":"Ramping","text":"In this example we ramp up the amplitude of our signal over 10 periods and we retrieve the first 12 periods of samples. Then after a wait we receive the next 12 periods. Afterwards we trigger the ramp down of the signal. As this is triggered by a command that is sent over the network it varies when the ramp down actually start. A ramp down can be triggered at a specific point with the help of a sequence.","category":"page"},{"location":"examples/ramping.html","page":"Ramping","title":"Ramping","text":"To run this example connect the RedPitaya in the following way.","category":"page"},{"location":"examples/ramping.html","page":"Ramping","title":"Ramping","text":"(Image: RedPitaya)","category":"page"},{"location":"examples/ramping.html","page":"Ramping","title":"Ramping","text":"It is also possible to update the signal type during the acquisition without going back to the CONFIGURATION mode.","category":"page"},{"location":"examples/ramping.html#Julia-Client","page":"Ramping","title":"Julia Client","text":"","category":"section"},{"location":"examples/ramping.html","page":"Ramping","title":"Ramping","text":"This and all other examples are located in the examples directory","category":"page"},{"location":"examples/ramping.html","page":"Ramping","title":"Ramping","text":"# Adapted from https://github.com/JuliaDocs/Documenter.jl/issues/499\nusing Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(open(f->read(f, String), \"../../../src/examples/julia/ramping.jl\"))\n```\n\"\"\")","category":"page"},{"location":"examples/ramping.html","page":"Ramping","title":"Ramping","text":"(Image: Ramping Example Results)","category":"page"},{"location":"cluster.html#Cluster","page":"Cluster","title":"Cluster","text":"","category":"section"},{"location":"cluster.html","page":"Cluster","title":"Cluster","text":"The RedPitayaDAQServer allows to use multiple RedPitayas in a fully synchronized fashion. One of the RedPitayas will act as the master and distribute its clock to all other RedPitayas acting as slaves.","category":"page"},{"location":"cluster.html#Prerequisites","page":"Cluster","title":"Prerequisites","text":"","category":"section"},{"location":"cluster.html","page":"Cluster","title":"Cluster","text":"Unfortunately, the STEMlab 125-4 does not allow cluster synchronization without hardware modifications. It is therefore necessary to resolder all slaves according to this documentation. The required mode for this project is 'Directly from FPGA' which requires resistors on R27 and R28. The heatsink has to be removed temporarily in order to unsolder the two resistor below it. In the following image you can see the new position of the 0 Ohm 0402 resistors. Since they get lost easily, make sure you have some in stock.","category":"page"},{"location":"cluster.html","page":"Cluster","title":"Cluster","text":"(Image: Cluster)","category":"page"},{"location":"cluster.html#Connections","page":"Cluster","title":"Connections","text":"","category":"section"},{"location":"cluster.html","page":"Cluster","title":"Cluster","text":"To run a cluster of RedPitayas one needs to connect the devices using different cables. An exemplary cluster with 3 devices is shown in the following image.","category":"page"},{"location":"cluster.html","page":"Cluster","title":"Cluster","text":"(Image: Cluster)","category":"page"},{"location":"cluster.html","page":"Cluster","title":"Cluster","text":"The clock is distributed from the master to the first slave via an SATA cable (green). Additional slaves can be used by connecting the next slave to the previous one. Additionally all slaves have connection from +3.3 Volt to DIO0_N.","category":"page"},{"location":"cluster.html","page":"Cluster","title":"Cluster","text":"In order to send a mutual trigger signal for starting the acquisition and the signal generation, you also have to connect the master's DIO5_P pin with the DIO0_P pin of all devices including the master.","category":"page"},{"location":"client.html#Client","page":"Client Library","title":"Client","text":"","category":"section"},{"location":"client.html","page":"Client Library","title":"Client Library","text":"This page contains documentation of the public API of the Julia client. In the Julia REPL one can access this documentation by entering the help mode with ? and then writing the function for which the documentation should be shown.","category":"page"},{"location":"client.html#Connection-and-Communication","page":"Client Library","title":"Connection and Communication","text":"","category":"section"},{"location":"client.html","page":"Client Library","title":"Client Library","text":"RedPitayaDAQServer.RedPitaya\nRedPitayaDAQServer.RedPitaya(::String, ::Int64, ::Int64, ::Bool)\nRedPitayaDAQServer.send(::RedPitaya, ::String)\nRedPitayaDAQServer.query\nRedPitayaDAQServer.receive\nRedPitayaDAQServer.ServerMode\nRedPitayaDAQServer.serverMode\nRedPitayaDAQServer.serverMode!\nRedPitayaDAQServer.ScpiBatch\nRedPitayaDAQServer.@add_batch\nRedPitayaDAQServer.execute!\nRedPitayaDAQServer.push!(::ScpiBatch, ::Pair{K, T}) where {K<:Function, T<:Tuple}\nRedPitayaDAQServer.pop!(::ScpiBatch)\nRedPitayaDAQServer.clear!(::ScpiBatch)\nRedPitayaDAQServer.RedPitayaCluster\nRedPitayaDAQServer.RedPitayaCluster(::Vector{String}, ::Int64, ::Int64)\nRedPitayaDAQServer.length(::RedPitayaCluster)\nRedPitayaDAQServer.master","category":"page"},{"location":"client.html#RedPitayaDAQServer.RedPitaya","page":"Client Library","title":"RedPitayaDAQServer.RedPitaya","text":"RedPitaya\n\nStruct representing a connection to a RedPitayaDAQServer.\n\nContains the sockets used for communication and connection related metadata. Also contains fields for  client specific concepts such as periods, frames and calibration values. \n\n\n\n\n\n","category":"type"},{"location":"client.html#RedPitayaDAQServer.RedPitaya-Tuple{String, Int64, Int64, Bool}","page":"Client Library","title":"RedPitayaDAQServer.RedPitaya","text":"RedPitaya(ip [, port = 5025, dataPort=5026, isMaster = false])\n\nConstruct a RedPitaya.\n\nDuring the construction the connection is established and the calibration values are loaded from the RedPitayas EEPROM. Throws an error if a timeout occurs while attempting to connect.\n\nExamples\n\njulia> rp = RedPitaya(\"192.168.1.100\");\n\njulia> decimation!(rp, 8)\ntrue\n\njulia> decimation(rp)\n8\n\n\n\n\n\n","category":"method"},{"location":"client.html#Sockets.send-Tuple{RedPitaya, String}","page":"Client Library","title":"Sockets.send","text":"send(rp::RedPitaya, cmd::String)\n\nSend a command to the RedPitaya. Appends delimiter.\n\n\n\n\n\n","category":"method"},{"location":"client.html#RedPitayaDAQServer.query","page":"Client Library","title":"RedPitayaDAQServer.query","text":"query(rp::RedPitaya, cmd [, timeout = 5.0, N = 100])\n\nSend a query to the RedPitaya command socket. Return reply as String.\n\nWaits for timeout seconds and checks every timeout/N seconds.\n\nSee also receive.\n\n\n\n\n\nquery(rp::RedPitaya, cmd, T::Type [timeout = 5.0, N = 100])\n\nSend a query to the RedPitaya. Parse reply as T.\n\nWaits for timeout seconds and checks every timeout/N seconds.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.receive","page":"Client Library","title":"RedPitayaDAQServer.receive","text":"receive(rp::RedPitaya)\n\nReceive a String from the RedPitaya command socket. Reads until a whole line is received\n\n\n\n\n\nreceive(rp::RedPitaya, timeout::Number)\n\nReceive a string from the RedPitaya command socket. Reads until a whole line is received or timeout seconds passed. In the latter case an error is thrown.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.ServerMode","page":"Client Library","title":"RedPitayaDAQServer.ServerMode","text":"ServerMode\n\nRepresent the different modes the server can be in. Valid values are CONFIGURATION, ACQUISITION and TRANSMISSION.\n\nSee also serverMode, serverMode!.\n\n\n\n\n\n","category":"type"},{"location":"client.html#RedPitayaDAQServer.serverMode","page":"Client Library","title":"RedPitayaDAQServer.serverMode","text":"serverMode(rp::RedPitaya)\n\nReturn the mode of the server.\n\nExamples\n\njulia> serverMode!(rp, ACQUISITION);\ntrue\n\njulia> serverMode(rp)\nACQUISITION\n\n\n\n\n\nserverMode(rpc::RedPitayaCluster)\n\nAs with single RedPitaya, but applied to only the master.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.serverMode!","page":"Client Library","title":"RedPitayaDAQServer.serverMode!","text":"serverMode!(rp::RedPitaya, mode::ServerMode)\n\nSet the mode of the server. Valid values are \"CONFIGURATION\" and \"ACQUISITION\".\n\nExamples\n\njulia> serverMode!(rp, ACQUISITION);\ntrue\n\njulia> serverMode(rp)\nACQUISITION\n\n\n\n\n\nserverMode!(rp::RedPitaya, mode::ServerMode)\n\nSet the mode of the server.\n\nExamples\n\njulia> serverMode!(rp, ACQUISITION);\ntrue\n\njulia> serverMode(rp)\nACQUISITION\n\n\n\n\n\nserverMode!(rpc::RedPitayaCluster, value)\n\nAs with single RedPitaya, but applied to all RedPitayas in a cluster.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.ScpiBatch","page":"Client Library","title":"RedPitayaDAQServer.ScpiBatch","text":"ScpiBatch\n\nStruct representing a batch of SCPI commands for a RedPitaya. Only commands that interact exclusively with the command socket should be used in a batch.\n\n\n\n\n\n","category":"type"},{"location":"client.html#RedPitayaDAQServer.@add_batch","page":"Client Library","title":"RedPitayaDAQServer.@add_batch","text":"@add_batch batch cmd\n\nAppend a usual RedPitaya function to the given batch instead of evaluating it directly.\n\nSee also ScpiBatch, push!, execute!\n\nExamples\n\njulia>  execute!(rp) do b\n          @add_batch b serverMode!(rp, CONFIGURATION)\n        end\n\n\n\n\n\n","category":"macro"},{"location":"client.html#RedPitayaDAQServer.execute!","page":"Client Library","title":"RedPitayaDAQServer.execute!","text":"execute!(rp::RedPitaya, batch::ScpiBatch)\n\nExecutes all commands of the given batch. Returns an array of the results in the order of the commands. An element is nothing if the command has no return value.\n\n\n\n\n\nexecute!(rpc::RedPitayaCluster, batch::ScpiBatch)\n\nExecutes all commands of the given batch. Returns an array of the results in the order of the commands.\n\nEach element of the result array is again an array containing the return values of the RedPitayas. An element of an inner array is nothing if the command has no return value.\n\n\n\n\n\nexecute!(f::Function, rp::Union{RedPitaya, RedPitayaCluster})\n\nOpen a ScpiBatch and evaluate the function f. If no exception was thrown, execute the opened batch.\n\nSee also ScpiBatch, push!, @add_batch\n\nExamples\n\njulia>  execute!(rp) do b\n          @add_batch b serverMode!(rp, CONFIGURATION)\n          @add_batch b amplitudeDAC!(rp, 1, 1, 0.2)\n        end\n\n\n\n\n\n","category":"function"},{"location":"client.html#Base.push!-Union{Tuple{T}, Tuple{K}, Tuple{ScpiBatch, Pair{K, T}}} where {K<:Function, T<:Tuple}","page":"Client Library","title":"Base.push!","text":"push!(batch::ScpiBatch, cmd::Pair{K, T}) where {K<:Function, T<:Tuple}\n\nAdd the given function and arguments to the batch\n\nExamples\n\njulia> batch = ScpiBatch() \n\njulia> push!(batch, amplitudeDAC! => (1, 1, 0.2))\n\n\n\n\n\n","category":"method"},{"location":"client.html#Base.pop!-Tuple{ScpiBatch}","page":"Client Library","title":"Base.pop!","text":"pop!(batch::ScpiBatch)\n\nRemove the last added command from the batch\n\n\n\n\n\n","category":"method"},{"location":"client.html#RedPitayaDAQServer.clear!-Tuple{ScpiBatch}","page":"Client Library","title":"RedPitayaDAQServer.clear!","text":"clear!(batch::ScpiBatch)\n\nRemove all commands from the batch\n\n\n\n\n\n","category":"method"},{"location":"client.html#RedPitayaDAQServer.RedPitayaCluster","page":"Client Library","title":"RedPitayaDAQServer.RedPitayaCluster","text":"RedPitayaCluster\n\nStruct representing a cluster of RedPitayas. Such a cluster should share a common clock and master trigger.\n\nThe structure implements the indexing and iterable interfaces.\n\n\n\n\n\n","category":"type"},{"location":"client.html#RedPitayaDAQServer.RedPitayaCluster-Tuple{Vector{String}, Int64, Int64}","page":"Client Library","title":"RedPitayaDAQServer.RedPitayaCluster","text":"RedPitayaCluster(hosts::Vector{String} [, port = 5025])\n\nConstruct a RedPitayaCluster.\n\nDuring the construction the first host is labelled the master RedPitaya of a cluster and all RedPitayas are set to using the EXTERNAL trigger mode.\n\nSee also RedPitaya, master.\n\nExamples\n\njulia> rpc = RedPitayaCluster([\"192.168.1.100\", \"192.168.1.101\"]);\n\njulia> rp = master(rpc)\n\njulia> rp == rpc[1]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"client.html#Base.length-Tuple{RedPitayaCluster}","page":"Client Library","title":"Base.length","text":"length(rpc::RedPitayaCluster)\n\nReturn the number of RedPitayas in cluster rpc.\n\n\n\n\n\n","category":"method"},{"location":"client.html#RedPitayaDAQServer.master","page":"Client Library","title":"RedPitayaDAQServer.master","text":"master(rpc::RedPitayaCluster)\n\nReturn the master RedPitaya of the cluster.\n\n\n\n\n\n","category":"function"},{"location":"client.html#ADC-Configuration","page":"Client Library","title":"ADC Configuration","text":"","category":"section"},{"location":"client.html","page":"Client Library","title":"Client Library","text":"RedPitayaDAQServer.TriggerMode\nRedPitayaDAQServer.triggerMode\nRedPitayaDAQServer.triggerMode!\nRedPitayaDAQServer.keepAliveReset\nRedPitayaDAQServer.keepAliveReset!\nRedPitayaDAQServer.decimation\nRedPitayaDAQServer.decimation!\nRedPitayaDAQServer.samplesPerPeriod\nRedPitayaDAQServer.samplesPerPeriod!\nRedPitayaDAQServer.periodsPerFrame\nRedPitayaDAQServer.periodsPerFrame!\nRedPitayaDAQServer.calibADCOffset\nRedPitayaDAQServer.calibADCOffset!\nRedPitayaDAQServer.calibADCScale\nRedPitayaDAQServer.calibADCScale!","category":"page"},{"location":"client.html#RedPitayaDAQServer.TriggerMode","page":"Client Library","title":"RedPitayaDAQServer.TriggerMode","text":"TriggerMode\n\nRepresent the different trigger modes the FPGA image can have. Valid value are INTERNAL and EXTERNAL.\n\nSee triggerMode, triggerMode!.\n\n\n\n\n\n","category":"type"},{"location":"client.html#RedPitayaDAQServer.triggerMode","page":"Client Library","title":"RedPitayaDAQServer.triggerMode","text":"triggerMode(rpc::RedPitayaCluster)\n\nAs with single RedPitaya, but applied to only the master.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.triggerMode!","page":"Client Library","title":"RedPitayaDAQServer.triggerMode!","text":"triggerMode!(rp::RedPitaya, mode::String)\n\nSet the trigger mode of the RedPitaya. Return true if the command was successful.\n\n\n\n\n\ntriggerMode!(rp::RedPitaya, mode::String)\n\nSet the trigger mode of the RedPitaya. Return true if the command was successful.\n\n\n\n\n\ntriggerMode!(rpc::RedPitayaCluster, value)\n\nAs with single RedPitaya, but applied to all RedPitayas in a cluster.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.keepAliveReset","page":"Client Library","title":"RedPitayaDAQServer.keepAliveReset","text":"keepAliveReset(rp::RedPitaya)\n\nDetermine whether the keepAliveReset is set.\n\n\n\n\n\nkeepAliveReset(rpc::RedPitayaCluster)\n\nAs with single RedPitaya, but applied to only the master.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.keepAliveReset!","page":"Client Library","title":"RedPitayaDAQServer.keepAliveReset!","text":"keepAliveReset!(rp::RedPitaya, val::Bool)\n\nSet the keepAliveReset to val.\n\n\n\n\n\nkeepAliveReset!(rpc::RedPitayaCluster, value)\n\nAs with single RedPitaya, but applied to all RedPitayas in a cluster.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.decimation","page":"Client Library","title":"RedPitayaDAQServer.decimation","text":"decimation(rp::RedPitaya)\n\nReturn the decimation of the RedPitaya.\n\nExamples\n\njulia> decimation!(rp, 8)\ntrue\n\njulia> decimation(rp)\n8\n\n\n\n\n\ndecimation(rpc::RedPitayaCluster)\n\nAs with single RedPitaya, but applied to only the master.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.decimation!","page":"Client Library","title":"RedPitayaDAQServer.decimation!","text":"decimation!(rp::RedPitaya, dec)\n\nSet the decimation of the RedPitaya. Return true if the command was successful.\n\nExamples\n\njulia> decimation!(rp, 8)\ntrue\n\njulia> decimation(rp)\n8\n\n\n\n\n\ndecimation!(rpc::RedPitayaCluster, value)\n\nAs with single RedPitaya, but applied to all RedPitayas in a cluster.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.samplesPerPeriod","page":"Client Library","title":"RedPitayaDAQServer.samplesPerPeriod","text":"samplesPerPeriod(rp::RedPitaya)\n\nReturn the number of samples per period.\n\nExample\n\njulia> samplesPerPeriod!(rp, 256)\ntrue\n\njulia> samplesPerPeriod(rp)\n256\n\n\n\n\n\n\nsamplesPerPeriod(rpc::RedPitayaCluster)\n\nAs with single RedPitaya, but applied to only the master.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.samplesPerPeriod!","page":"Client Library","title":"RedPitayaDAQServer.samplesPerPeriod!","text":"samplesPerPeriod!(rp::RedPitaya, value)\n\nSet the number of samples per period.\n\nExample\n\njulia> samplesPerPeriod!(rp, 256)\ntrue\n\njulia> samplesPerPeriod(rp)\n256\n\n\n\n\n\n\nsamplesPerPeriod!(rpc::RedPitayaCluster, value)\n\nAs with single RedPitaya, but applied to all RedPitayas in a cluster.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.periodsPerFrame","page":"Client Library","title":"RedPitayaDAQServer.periodsPerFrame","text":"periodsPerFrame(rp::RedPitaya)\n\nReturn the number of periods per frame.\n\nExample\n\njulia> periodsPerFrame!(rp, 16)\n\njulia> periodsPerFrame(rp)\n16\n\n\n\n\n\n\nperiodsPerFrame(rpc::RedPitayaCluster)\n\nAs with single RedPitaya, but applied to only the master.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.periodsPerFrame!","page":"Client Library","title":"RedPitayaDAQServer.periodsPerFrame!","text":"periodsPerFrame(rp::RedPitaya, value)\n\nSet the number of periods per frame.\n\nExample\n\njulia> periodsPerFrame!(rp, 16)\n\njulia> periodsPerFrame(rp)\n16\n\n\n\n\n\n\nperiodsPerFrame!(rpc::RedPitayaCluster, value)\n\nAs with single RedPitaya, but applied to all RedPitayas in a cluster.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.calibADCOffset","page":"Client Library","title":"RedPitayaDAQServer.calibADCOffset","text":"calibADCOffset(rp::RedPitaya, channel::Integer)\n\nRetrieve the calibration ADC offset for given channel from the RedPitayas EEPROM.\n\nSee also convertSamplesToPeriods,convertSamplesToFrames.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.calibADCOffset!","page":"Client Library","title":"RedPitayaDAQServer.calibADCOffset!","text":"calibADCOffset!(rp::RedPitaya, channel::Integer, val)\n\nStore calibration ADC offset val for given channel into the RedPitayas EEPROM. Absolute value has to be smaller than 1.0 V.\n\nSee also convertSamplesToPeriods,convertSamplesToFrames.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.calibADCScale","page":"Client Library","title":"RedPitayaDAQServer.calibADCScale","text":"calibADCScale(rp::RedPitaya, channel::Integer)\n\nRetrieve the calibration ADC scale for given channel from the RedPitayas EEPROM.\n\nSee also convertSamplesToPeriods,convertSamplesToFrames.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.calibADCScale!","page":"Client Library","title":"RedPitayaDAQServer.calibADCScale!","text":"calibADCScale(rp::RedPitaya, channel::Integer)\n\nStore calibration ADC scale val for given channel into the RedPitayas EEPROM. See also convertSamplesToPeriods,convertSamplesToFrames.\n\n\n\n\n\n","category":"function"},{"location":"client.html#DAC-Configuration","page":"Client Library","title":"DAC Configuration","text":"","category":"section"},{"location":"client.html","page":"Client Library","title":"Client Library","text":"RedPitayaDAQServer.amplitudeDAC\nRedPitayaDAQServer.amplitudeDAC!\nRedPitayaDAQServer.offsetDAC\nRedPitayaDAQServer.offsetDAC!\nRedPitayaDAQServer.frequencyDAC\nRedPitayaDAQServer.frequencyDAC!\nRedPitayaDAQServer.phaseDAC\nRedPitayaDAQServer.phaseDAC!\nRedPitayaDAQServer.SignalType\nRedPitayaDAQServer.signalTypeDAC\nRedPitayaDAQServer.signalTypeDAC!\nRedPitayaDAQServer.numSeqChan\nRedPitayaDAQServer.numSeqChan!\nRedPitayaDAQServer.samplesPerStep\nRedPitayaDAQServer.samplesPerStep!\nRedPitayaDAQServer.stepsPerFrame!\nRedPitayaDAQServer.clearSequences!\nRedPitayaDAQServer.popSequence!\nRedPitayaDAQServer.length(::AbstractSequence)\nRedPitayaDAQServer.start\nRedPitayaDAQServer.calibDACOffset\nRedPitayaDAQServer.calibDACOffset!\nRedPitayaDAQServer.calibDACScale\nRedPitayaDAQServer.calibDACScale!","category":"page"},{"location":"client.html#RedPitayaDAQServer.amplitudeDAC","page":"Client Library","title":"RedPitayaDAQServer.amplitudeDAC","text":"amplitudeDAC(rp::RedPitaya, channel, component)\n\nReturn the amplitude of composite waveform component for channel.\n\nSee amplitudeDAC!.\n\nExamples\n\njulia> amplitudeDAC!(rp, 1, 1, 0.5);\ntrue\n\njulia> amplitudeDAC(rp, 1, 1)\n0.5\n\n\n\n\n\namplitudeDAC(rpc::RedPitayaCluster, chan::Integer, component::Integer)\n\nAs with single RedPitaya. The chan index refers to the total channel available in a cluster, two per RedPitaya. For example channel 4 would refer to the second channel of the second RedPitaya.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.amplitudeDAC!","page":"Client Library","title":"RedPitayaDAQServer.amplitudeDAC!","text":"amplitudeDAC!(rp::RedPitaya, channel, component, value)\n\nSet the amplitude of composite waveform component for channel. Return true if the command was successful.\n\nSee amplitudeDAC.\n\nExamples\n\njulia> amplitudeDAC!(rp, 1, 1, 0.5);\ntrue\n\njulia> amplitudeDAC(rp, 1, 1)\n0.5\n\n\n\n\n\namplitudeDAC!(rpc::RedPitayaCluster, chan::Integer, component::Integer, value)\n\nAs with single RedPitaya. The chan index refers to the total channel available in a cluster, two per RedPitaya. For example channel 4 would refer to the second channel of the second RedPitaya.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.offsetDAC","page":"Client Library","title":"RedPitayaDAQServer.offsetDAC","text":"offsetDAC(rp::RedPitaya, channel)\n\nReturn the offset for channel.\n\nSee offsetDAC!.\n\nExamples\n\njulia> offsetDAC!(rp, 1, 0.2);\ntrue\n\njulia> offsetDAC(rp, 1)\n0.2\n\n\n\n\n\noffsetDAC(rpc::RedPitayaCluster, chan::Integer)\n\nAs with single RedPitaya. The chan index refers to the total channel available in a cluster, two per RedPitaya. For example channel 4 would refer to the second channel of the second RedPitaya.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.offsetDAC!","page":"Client Library","title":"RedPitayaDAQServer.offsetDAC!","text":"offsetDAC!(rp::RedPitaya, channel, value)\n\nSet the offset for channel. Return true if the command was successful.\n\nSee offsetDAC.\n\nExamples\n\njulia> offsetDAC!(rp, 1, 0.2);\ntrue\n\njulia> offsetDAC(rp, 1)\n0.2\n\n\n\n\n\noffsetDAC!(rpc::RedPitayaCluster, chan::Integer, value)\n\nAs with single RedPitaya. The chan index refers to the total channel available in a cluster, two per RedPitaya. For example channel 4 would refer to the second channel of the second RedPitaya.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.frequencyDAC","page":"Client Library","title":"RedPitayaDAQServer.frequencyDAC","text":"frequencyDAC(rp::RedPitaya, channel, component)\n\nReturn the frequency of composite waveform component for channel.\n\nSee frequencyDAC!.\n\nExamples\n\njulia> frequencyDAC!(rp, 1, 1, 2400);\ntrue\n\njulia> frequencyDAC(rp, 1, 1)\n2400\n\n\n\n\n\nfrequencyDAC(rpc::RedPitayaCluster, chan::Integer, component::Integer)\n\nAs with single RedPitaya. The chan index refers to the total channel available in a cluster, two per RedPitaya. For example channel 4 would refer to the second channel of the second RedPitaya.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.frequencyDAC!","page":"Client Library","title":"RedPitayaDAQServer.frequencyDAC!","text":"frequencyDAC!(rp::RedPitaya, channel, component, value)\n\nSet the frequency of composite waveform component for channel. Return true if the command was successful.\n\nSee frequencyDAC.\n\nExamples\n\njulia> frequencyDAC!(rp, 1, 1, 2400);\ntrue\n\njulia> frequencyDAC(rp, 1, 1)\n2400\n\n\n\n\n\nfrequencyDAC!(rpc::RedPitayaCluster, chan::Integer, component::Integer, value)\n\nAs with single RedPitaya. The chan index refers to the total channel available in a cluster, two per RedPitaya. For example channel 4 would refer to the second channel of the second RedPitaya.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.phaseDAC","page":"Client Library","title":"RedPitayaDAQServer.phaseDAC","text":"phaseDAC(rp::RedPitaya, channel, component)\n\nReturn the phase of composite waveform component for channel.\n\nSee phaseDAC!.\n\nExamples\n\njulia> phaseDAC!(rp, 1, 1, 0.0);\ntrue\n\njulia> phaseDAC(rp, 1, 0.0)\n0.0\n\n\n\n\n\nphaseDAC(rpc::RedPitayaCluster, chan::Integer, component::Integer)\n\nAs with single RedPitaya. The chan index refers to the total channel available in a cluster, two per RedPitaya. For example channel 4 would refer to the second channel of the second RedPitaya.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.phaseDAC!","page":"Client Library","title":"RedPitayaDAQServer.phaseDAC!","text":"phaseDAC!(rp::RedPitaya, channel, component, value)\n\nSet the phase of composite waveform component for channel. Return true if the command was successful.\n\nSee phaseDAC.\n\nExamples\n\njulia> phaseDAC!(rp, 1, 1, 0.0);\ntrue\n\njulia> phaseDAC(rp, 1, 0.0)\n0.0\n\n\n\n\n\nphaseDAC!(rpc::RedPitayaCluster, chan::Integer, component::Integer, value)\n\nAs with single RedPitaya. The chan index refers to the total channel available in a cluster, two per RedPitaya. For example channel 4 would refer to the second channel of the second RedPitaya.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.SignalType","page":"Client Library","title":"RedPitayaDAQServer.SignalType","text":"SignalType\n\nRepresent the different types of signals the fast DAC can have. Valid values are SINE, SQUARE, TRIANGLE and SAWTOOTH.\n\nSee signalTypeDAC, signalTypeDAC!.\n\n\n\n\n\n","category":"type"},{"location":"client.html#RedPitayaDAQServer.signalTypeDAC","page":"Client Library","title":"RedPitayaDAQServer.signalTypeDAC","text":"signalTypeDAC!(rp::RedPitaya, channel, value)\n\nReturn the signalType of composite waveform for channel.\n\nSee signalTypeDAC!.\n\nExamples\n\njulia> signalTypeDAC!(rp, 1, SINE);\ntrue\n\njulia> signalTypeDAC(rp, 1)\nSINE\n\n\n\n\n\nsignalTypeDAC(rpc::RedPitayaCluster, chan::Integer, component::Integer)\n\nAs with single RedPitaya. The chan index refers to the total channel available in a cluster, two per RedPitaya. For example channel 4 would refer to the second channel of the second RedPitaya.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.signalTypeDAC!","page":"Client Library","title":"RedPitayaDAQServer.signalTypeDAC!","text":"signalTypeDAC!(rp::RedPitaya, channel, value)\n\nSet the signalType of composite waveform for channel. Return true if the command was successful.\n\nSee signalTypeDAC.\n\nExamples\n\njulia> signalTypeDAC!(rp, 1, SINE);\ntrue\n\njulia> signalTypeDAC(rp, 1)\nSINE\n\n\n\n\n\nsignalTypeDAC!(rpc::RedPitayaCluster, chan::Integer, component::Integer, value)\n\nAs with single RedPitaya. The chan index refers to the total channel available in a cluster, two per RedPitaya. For example channel 4 would refer to the second channel of the second RedPitaya.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.samplesPerStep","page":"Client Library","title":"RedPitayaDAQServer.samplesPerStep","text":"samplesPerStep(rp::RedPitaya)\n\nReturn the number of samples per sequence step.\n\n\n\n\n\nsamplesPerStep(rpc::RedPitayaCluster)\n\nAs with single RedPitaya, but applied to only the master.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.samplesPerStep!","page":"Client Library","title":"RedPitayaDAQServer.samplesPerStep!","text":"samplesPerStep!(rp::RedPitaya, value::Integer)\n\nSet the number of samples per sequence step. Return true if the command was successful.\n\n\n\n\n\nsamplesPerStep!(rpc::RedPitayaCluster, value)\n\nAs with single RedPitaya, but applied to all RedPitayas in a cluster.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.stepsPerFrame!","page":"Client Library","title":"RedPitayaDAQServer.stepsPerFrame!","text":"stepsPerFrame!(rp::RedPitaya, stepsPerFrame)\n\nSet the number of samples per steps s.t. stepsPerFrame sequence steps in a frame.\n\nSee samplesPerPeriod!, periodsPerFrame!, samplesPerStep!.\n\n\n\n\n\n","category":"function"},{"location":"client.html#Base.length-Tuple{AbstractSequence}","page":"Client Library","title":"Base.length","text":"length(seq::AbstractSequence)\n\nReturn the number of steps a sequence will take.\n\n\n\n\n\n","category":"method"},{"location":"client.html#RedPitayaDAQServer.start","page":"Client Library","title":"RedPitayaDAQServer.start","text":"start(seq::AbstractSequence)\n\nReturn the number of steps after which a sequence leaves the ramp up phase.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.calibDACOffset","page":"Client Library","title":"RedPitayaDAQServer.calibDACOffset","text":"calibDACOffset(rp::RedPitaya, channel::Integer)\n\nRetrieve the calibration DAC offset for given channel from the RedPitayas EEPROM \n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.calibDACOffset!","page":"Client Library","title":"RedPitayaDAQServer.calibDACOffset!","text":"calibDACOffset!(rp::RedPitaya, channel::Integer, val)\n\nStore calibration DAC offset val for given channel into the RedPitayas EEPROM.  This value is used by the server to offset the output voltage. Absolute value has to be smaller than 1.0 V. \n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.calibDACScale","page":"Client Library","title":"RedPitayaDAQServer.calibDACScale","text":"calibDACScale(rp::RedPitaya, channel::Integer)\n\nRetrieve the calibration DAC scale for given channel from the RedPitayas EEPROM.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.calibDACScale!","page":"Client Library","title":"RedPitayaDAQServer.calibDACScale!","text":"calibDACScale(rp::RedPitaya, channel::Integer)\n\nStore calibration DAC scale val for given channel into the RedPitayas EEPROM. This value is used by the server to scale the output voltage.\n\n\n\n\n\n","category":"function"},{"location":"client.html#Measurement-and-Transmission","page":"Client Library","title":"Measurement and Transmission","text":"","category":"section"},{"location":"client.html","page":"Client Library","title":"Client Library","text":"RedPitayaDAQServer.masterTrigger\nRedPitayaDAQServer.masterTrigger!\nRedPitayaDAQServer.currentWP\nRedPitayaDAQServer.currentFrame\nRedPitayaDAQServer.currentPeriod\nRedPitayaDAQServer.SampleChunk\nRedPitayaDAQServer.PerformanceData\nRedPitayaDAQServer.readSamples\nRedPitayaDAQServer.readFrames\nRedPitayaDAQServer.convertSamplesToFrames","category":"page"},{"location":"client.html#RedPitayaDAQServer.masterTrigger","page":"Client Library","title":"RedPitayaDAQServer.masterTrigger","text":"masterTrigger(rp::RedPitaya)\n\nDetermine whether the master trigger is set.\n\nExample\n\njulia> masterTrigger!(rp, true)\n\njulia>masterTrigger(rp)\ntrue\n\n\n\n\n\nmasterTrigger(rpc::RedPitayaCluster)\n\nAs with single RedPitaya, but applied to only the master.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.masterTrigger!","page":"Client Library","title":"RedPitayaDAQServer.masterTrigger!","text":"masterTrigger!(rp::RedPitaya, val::Bool)\n\nSet the master trigger of the RedPitaya to val. Return true if the command was successful.\n\nExample\n\njulia> masterTrigger!(rp, true)\ntrue\n\njulia>masterTrigger(rp)\ntrue\n\n\n\n\n\nmasterTrigger(rpc::RedPitayaCluster, val::Bool)\n\nSet the master trigger of the cluster to val.\n\nFor val equals to true this is the same as calling the function on the RedPitaya returned by master(rpc). If val is false then the keepAliveReset is set to true for all RedPitayas in the cluster before the master trigger is disabled. Afterwards the keepAliveReset is set to false again.\n\nSee also master, keepAliveReset!.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.currentWP","page":"Client Library","title":"RedPitayaDAQServer.currentWP","text":"currentWP(rp::RedPitaya)\n\nReturn the current writepointer of the RedPitaya.\n\n\n\n\n\ncurrentWP(rpc::RedPitayaCluster)\n\nAs with single RedPitaya, but applied to only the master.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.currentFrame","page":"Client Library","title":"RedPitayaDAQServer.currentFrame","text":"currentFrame(rp::RedPitaya)\n\nReturn the current frame of the RedPitaya based on the current writepointer, samples per period and periods per frame.\n\nSee also currentWP, samplesPerPeriod, periodsPerFrame.\n\n\n\n\n\ncurrentFrame(rpc::RedPitayaCluster)\n\nAs with single RedPitaya, but applied to only the master.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.currentPeriod","page":"Client Library","title":"RedPitayaDAQServer.currentPeriod","text":"currentPeriod(rp::RedPitaya)\n\nReturn the current period of the RedPitaya based on the current writepointer and samples per period.\n\nSee also currentWP, samplesPerPeriod.\n\n\n\n\n\ncurrentPeriod(rpc::RedPitayaCluster)\n\nAs with single RedPitaya, but applied to only the master.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.SampleChunk","page":"Client Library","title":"RedPitayaDAQServer.SampleChunk","text":"SampleChunk\n\nStruct containing a matrix of samples and associated PerformanceData\n\nFields\n\nsamples::Matrix{Int16}: nxm matrix containing m samples for n channel\nperformance::Vector{PerformanceData}: PerformanceData object for each RedPitaya that transmitted samples\n\n\n\n\n\n","category":"type"},{"location":"client.html#RedPitayaDAQServer.readSamples","page":"Client Library","title":"RedPitayaDAQServer.readSamples","text":"readSamples(rp::RedPitaya, reqWP, numSamples)\n\nRetrieves numSamples from writepointer reqWP on. Throws error if samples can not be sent. Does not check if samples exist or fit within the buffer. For such features use readPipelinedSamples instead.\n\n\n\n\n\nreadSamples(rpu::Union{RedPitaya,RedPitayaCluster, RedPitayaClusterView}, wpStart::Int64, numOfRequestedSamples::Int64; chunkSize::Int64 = 25000, rpInfo=nothing)\n\nRequest and receive numOfRequestedSamples samples from wpStart on in a pipelined fashion. Return a matrix of samples.\n\nIf rpInfo is set to a RPInfo, the PerformanceData sent after every chunkSize samples will be pushed into rpInfo.\n\n\n\n\n\nreadSamples(rpu::Union{RedPitaya,RedPitayaCluster, RedPitayaClusterView}, wpStart::Int64, numOfRequestedSamples::Int64, channel::Channel; chunkSize::Int64 = 25000)\n\nRequest and receive numOfRequestedSamples samples from wpStart on in a pipelined fashion. The samples and associated PerformanceData are pushed into channel as a SampleChunk.\n\nSee SampleChunk.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.readFrames","page":"Client Library","title":"RedPitayaDAQServer.readFrames","text":"readFrames(rpu::Union{RedPitaya,RedPitayaCluster, RedPitayaClusterView}, startFrame, numFrames, numBlockAverages=1, numPeriodsPerPatch=1; rpInfo=nothing, chunkSize = 50000, useCalibration = false)\n\nRequest and receive numFrames frames from startFrame on.\n\nSee readSamples, convertSamplesToFrames, samplesPerPeriod, periodsPerFrame, updateCalib!.\n\nArguments\n\nrpu::Union{RedPitaya,RedPitayaCluster, RedPitayaClusterView}: RedPitayas to receive samples from.\nstartFrame: frame from which to start transmitting\nnumFrames: number of frames to read\nnumBlockAverages=1: see convertSamplesToFrames\nnumPeriodsPerPatch=1: see convertSamplesToFrames\nchunkSize=50000: see readSamples\nrpInfo=nothing: see readSamples\nuseCalibration: convert from Int16 samples to Float32 values based on RedPitayas calibration\n\n\n\n\n\n","category":"function"},{"location":"client.html#Utility","page":"Client Library","title":"Utility","text":"","category":"section"},{"location":"scpi.html#SCPI-Interface","page":"SCPI Interface","title":"SCPI Interface","text":"","category":"section"},{"location":"scpi.html","page":"SCPI Interface","title":"SCPI Interface","text":"For communication betten the server and the client an SCPI interface with custom commands is used. In the following tables an overview of the available commands and their behaviour is given. The Julia Client library encapsulates these commands into function calls, abstracting their communication details and also combining commands to manage a cluster of RedPitayas at the same time.","category":"page"},{"location":"scpi.html","page":"SCPI Interface","title":"SCPI Interface","text":"As a safe guard the server has different communcation modes and certain commands are only available in certain modes. To give an example, during an acquisition changing the sampling rate would result in unclear behaviour. To stop such a scenario the decimation can only be set in the CONFIGURATION mode and an acquisition can only be triggered in the ACQUISITION mode. The available modes are CONFIGURATION, ACQUISITION and TRANSMISSION (C, A, T, 😺). The former two are set by the client and the latter is set by the server during sample transmission.","category":"page"},{"location":"scpi.html","page":"SCPI Interface","title":"SCPI Interface","text":"After each SCPI command the server replies with true or false on the command socket depending on whether the given command was successfully excecuted. The exception to this rule are the commands which themselves just query values from the server.","category":"page"},{"location":"scpi.html#ADC-Configuration","page":"SCPI Interface","title":"ADC Configuration","text":"","category":"section"},{"location":"scpi.html","page":"SCPI Interface","title":"SCPI Interface","text":"Command Arguments Description Mode Example\nRP:ADC:DECimation decimation value [8, ..., n] Set the decimation factor of the base sampling rate C RP:ADC:DEC 8\nRP:ADC:DECimation?  Return the decimation factor Any RP:ADC:DEC?\nRP:TRIGger:MODe trigger mode (EXTERNAL, INTERNAL) Set the trigger mode, which trigger the RedPitaya listens to C RP:TRIG:MOD INTERNAL\nRP:TRIGger:MODe?  Return the trigger mode Any RP:TRIG:MOD?","category":"page"},{"location":"scpi.html#DAC-Configuration","page":"SCPI Interface","title":"DAC Configuration","text":"","category":"section"},{"location":"scpi.html","page":"SCPI Interface","title":"SCPI Interface","text":"Command Arguments Description Mode Example\nRP:DAC:CHannel#:COMPonent#:SIGnaltype channel (0, 1), (0, 1, 2, 3), signal type (SINE, TRIANGLE, SAWTOOTH) Set signal type of first component for given channel Any RP:DAC:CH0:SIG SINE\nRP:DAC:CHannel#:COMPonent#:SIGnaltype? channel (0, 1), component (0, 1, 2, 3) Return signal type of first component of given channel Any RP:DAC:CH1:SIG?\nRP:DAC:CHannel#:OFFset channel (0, 1), offset [-1, ..., 1] Set offset for given channel Any RP:DAC:CH1:OFF 0.1\nRP:DAC:CHannel#:OFFset? channel (0, 1) Return offset of given channel Any RP:DAC:CH0:OFF?\nRP:DAC:CHannel#:COMPonent#:AMPlitude channel (0, 1), component (0, 1, 2, 3),  amplitude[0, ..., 1] Set amplitude of given channel and component Any \nRP:DAC:CHannel#:COMPonent#:AMPlitude? channel (0, 1), component (0, 1, 2, 3) Return amplitude of given channel and component Any \nRP:DAC:CHannel#:COMPonent#:FREQuency channel (0, 1), component (0, 1, 2, 3), frequency Set frequency of given channel and component Any \nRP:DAC:CHannel#:COMPonent#:FREQuency? channel (0, 1), component (0, 1, 2, 3) Return frequency of given channel and component Any \nRP:DAC:CHannel#:COMPonent#:PHAse channel (0, 1), component (0, 1, 2, 3), phase Set phase of given channel and component Any \nRP:DAC:CHannel#:COMPonent#:PHAse? channel (0, 1), component (0, 1, 2, 3) Return phase of given channel and component Any \nRP:DAC:CHannel#:RAMPing channel (0, 1), ramping period Set length of ramping period C \nRP:DAC:CHannel#:RAMPing? channel (0, 1) Get length of ramping period Any \nRP:DAC:CHannel#:RAMPing:ENable channel (0, 1) ramping status (OFF, ON) Enable/disable ramping factor on given channel C \nRP:DAC:CHannel#:RAMPing:ENable? channel (0, 1) Return enable ramping status of given channel Any \nRP:DAC:CHannel#:RAMPing:DoWN channel (0, 1), ramp down status (OFF, ON) Enable/disable ramp down flag for given channel A, T \nRP:DAC:CHannel#:RAMPing:DoWN? channel (0, 1) Get ramp down flag for given channel Any \nRP:DAC:RAMPing:STATus?  Return the ramping status Any ","category":"page"},{"location":"scpi.html#Sequence-Configuration","page":"SCPI Interface","title":"Sequence Configuration","text":"","category":"section"},{"location":"scpi.html","page":"SCPI Interface","title":"SCPI Interface","text":"The server maintains three acqusition sequences. When the server is in theCONFIGURATION mode a client can configure a set of three sequences. If the current configured sequences fits the desired signal, a client can intstruct the server to set the sequences. This moves the configuration sequences to the acquisition sequences and writes the first values to the FPGA buffer.","category":"page"},{"location":"scpi.html","page":"SCPI Interface","title":"SCPI Interface","text":"During an active trigger the buffer is periodically updated by the server. If the server recognizes the end of a sequence, it sets the amplitudes of the waveform components to 0.","category":"page"},{"location":"scpi.html","page":"SCPI Interface","title":"SCPI Interface","text":"Command Arguments Description Mode Example\nRP:DAC:SEQ:CLocKdivider divider Set the clock divider with which the sequence advances C \nRP:DAC:SEQ:CLocKdivider?  Return the clock divider Any \nRP:DAC:SEQ:SAMPlesperstep samples per step Set the clock divider such that the sequence advances every given number of samples. C \nRP:DAC:SEQ:SAMPlesperstep?  Return the number of samples per step Any \nRP:DAC:SEQ:CHan numChan (1, 2, 3, 4) Set the number of sequence channel C \nRP:DAC:SEQ:CHan?  Return the number of sequence channel  \nRP:DAC:SEQ:LUT steps, repetitions Instruct the server to receive a LUT over the data socket C RP:DAC:SEQ:LUT 10,2\nRP:DAC:SEQ:LUT:ENaBle  Instruct the server to receive an enable LUT over the data socket of the same shape as the regular LUT C \nRP:DAC:SEQ:LUT:UP steps, repetitions Instruct the server to receive a ramp up LUT over the data socket C \nRP:DAC:SEQ:LUT:DOWN steps, repetitions Instruct the server to receive a ramp down LUT over the data socket C \nRP:DAC:SEQ:CLEAR  Clear the set sequence values from the FPGA buffer C \nRP:DAC:SEQ:SET  Set the current configured sequence as the acquisition sequence C ","category":"page"},{"location":"scpi.html#Acquisition-and-Transmission","page":"SCPI Interface","title":"Acquisition and Transmission","text":"","category":"section"},{"location":"scpi.html","page":"SCPI Interface","title":"SCPI Interface","text":"Command Arguments Description Mode Example\nRP:TRIGger trigger status (OFF, ON) Set the internal trigger status A RP:TRIG ON\nRP:TRIGger?  Return the trigger status Any RP:TRIG?\nRP:TRIGger:ALiVe keep alive status (OFF, ON) Set the keep alive bypass A RP:TRIG:ALV OFF\nRP:TRIGger:ALiVe?  Return the keep alive status Any RP:TRIG:ALV?\nRP:ADC:WP:CURRent?  Return the current writepointer A, T RP:ADC:WP?\nRP:ADC:DATa? readpointer, number of samples Transmit number of samples from the buffer component of the readpointer over the data socket. Return true on the command socket if transmission is started. A RP:ADC:DATa? 400,1024\nRP:ADC:DATa:PIPElined? readpointer, number of samples, chunksize Transmit number of samples from the readpointer on in chunks of chunksize over the data socket. After every chunk status and performance data is transmitted over the data socket. Return true if pipeline was started. A RP:ADC:DAT:PIPE? 400,1024,128\nRP:STATus?  Transmit status as one byte with flags from lower bits: overwritten, corrupted, lost steps, master trigger, sequence active Any RP:STAT?\nRP:STATus:OVERwritten?  Transmit overwritten flag Any RP:STAT:OVER?\nRP:STATus:CORRupted?  Transmit corrupted flag Any RP:STAT:CORR?\nRP:STATus:LOSTSteps?  Transmit lost steps flag Any RP:STAT:LOSTS?\nRP:PERF?  Transmit ADC and DAC performance data Any RP:PERF?","category":"page"},{"location":"scpi.html#Calibration","page":"SCPI Interface","title":"Calibration","text":"","category":"section"},{"location":"scpi.html","page":"SCPI Interface","title":"SCPI Interface","text":"Command Arguments Description Mode Example\nRP:CALib:ADC:CHannel#:OFFset channel (0, 1), offset Store the ADC offset value for given channel in EEPROM C RP:CAL:ADC:CH0:OFF 0.2\nRP:CALib:ADC:CHannel#:OFFset? channel (0, 1) Return the ADC offset value for given channel from EEPROM Any RP:CAL:ADC:CH1:OFF?\nRP:CALib:ADC:CHannel#:SCAle channel (0, 1), scale Store the ADC scale value for given channel in EEPROM C RP:CAL:ADC:CH1:SCA 1.0\nRP:CALib:ADC:CHannel#:SCAle? channel (0, 1) Return the ADC scale value for given channel from EEPROM Any RP:CAL:ADC:CH1:SCA?\nRP:CALib:DAC:CHannel#:OFFset channel (0, 1), offset Store the DAC offset value for given channel in EEPROM C RP:CAL:DAC:CH0:OFF 0.2\nRP:CALib:DAC:CHannel#:OFFset? channel (0, 1) Return the DAC offset value for given channel from EEPROM Any RP:CAL:DAC:CH1:OFF?\nRP:CALib:DAC:CHannel#:SCAle channel (0, 1), scale Store the DAC scale value for given channel in EEPROM C RP:CAL:DAC:CH1:SCA 1.0\nRP:CALib:DAC:CHannel#:SCAle? channel (0, 1) Return the DAC scale value for given channel from EEPROM Any RP:CAL:DAC:CH1:SCA?","category":"page"},{"location":"scpi.html#DIO","page":"SCPI Interface","title":"DIO","text":"","category":"section"},{"location":"scpi.html","page":"SCPI Interface","title":"SCPI Interface","text":"Command Arguments Description Example\nRP:DIO:DIR identifier of pin, direction (IN/OUT) Set the direction of the DIO RP:DIO:DIR DIO7_P,IN\nRP:DIO identifier of pin, value (0/1) Set the output of the DIO RP:DIO DIO7_P,1\nRP:DIO? identifier of pin Get the input of the DIO RP:DIO? DIO7_P","category":"page"},{"location":"examples/seqRamping.html#Sequence-Ramping-Example","page":"Sequence Ramping","title":"Sequence Ramping Example","text":"","category":"section"},{"location":"examples/seqRamping.html","page":"Sequence Ramping","title":"Sequence Ramping","text":"In this example we combine the ramping and the sequence example to create a signal with known/predictable ramping behaviour. The ramping period is independant of the sequence. The sequence we use is a sequence that holds the first value of our intended sequence for the duration of the given number of ramping steps, which spans the ramp up period.","category":"page"},{"location":"examples/seqRamping.html","page":"Sequence Ramping","title":"Sequence Ramping","text":"At the end of the \"regular\" sequence portion, the ramp down is triggered and the sequence holds the last value of the \"regular\" sequence until the end of the ramp down.","category":"page"},{"location":"examples/seqRamping.html","page":"Sequence Ramping","title":"Sequence Ramping","text":"(Image: RedPitaya)","category":"page"},{"location":"examples/seqRamping.html","page":"Sequence Ramping","title":"Sequence Ramping","text":"It is also possible to update the signal type during the acquisition without going back to the CONFIGURATION mode.","category":"page"},{"location":"examples/seqRamping.html#Julia-Client","page":"Sequence Ramping","title":"Julia Client","text":"","category":"section"},{"location":"examples/seqRamping.html","page":"Sequence Ramping","title":"Sequence Ramping","text":"This and all other examples are located in the examples directory","category":"page"},{"location":"examples/seqRamping.html","page":"Sequence Ramping","title":"Sequence Ramping","text":"# Adapted from https://github.com/JuliaDocs/Documenter.jl/issues/499\nusing Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(open(f->read(f, String), \"../../../src/examples/julia/seqRamping.jl\"))\n```\n\"\"\")","category":"page"},{"location":"examples/seqRamping.html","page":"Sequence Ramping","title":"Sequence Ramping","text":"(Image: Sequence Ramping Example Results)","category":"page"},{"location":"examples/producerConsumer.html#Continous-Signal-Acquisition-Example","page":"Continous Signal Acquisition","title":"Continous Signal Acquisition Example","text":"","category":"section"},{"location":"examples/producerConsumer.html","page":"Continous Signal Acquisition","title":"Continous Signal Acquisition","text":"As is mentioned in the Acquisition section, the transmission rate of the server heavily depends on the available network and the way a client processes the samples. This example shows how one can write a thread dedicated to just receiving samples and one (or more) threads dedicated to processing samples. As the example contains no visualization, there is no need for a specific RedPitaya setup.","category":"page"},{"location":"examples/producerConsumer.html#Julia-Client","page":"Continous Signal Acquisition","title":"Julia Client","text":"","category":"section"},{"location":"examples/producerConsumer.html","page":"Continous Signal Acquisition","title":"Continous Signal Acquisition","text":"This and all other examples are located in the examples directory","category":"page"},{"location":"examples/producerConsumer.html","page":"Continous Signal Acquisition","title":"Continous Signal Acquisition","text":"# Adapted from https://github.com/JuliaDocs/Documenter.jl/issues/499\nusing Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(open(f->read(f, String), \"../../../src/examples/julia/producerConsumer.jl\"))\n```\n\"\"\")","category":"page"},{"location":"devtips.html#Development-Hints","page":"Development Tips","title":"Development Hints","text":"","category":"section"},{"location":"devtips.html","page":"Development Tips","title":"Development Tips","text":"On this slide some development hints are summarized. These might change regularely if things are properly integrated into the framework.","category":"page"},{"location":"devtips.html#Alpine-Linux","page":"Development Tips","title":"Alpine Linux","text":"","category":"section"},{"location":"devtips.html","page":"Development Tips","title":"Development Tips","text":"The Alpine linux as currently a root folder with only 185.8M free space, which disallows installing more","category":"page"},{"location":"devtips.html","page":"Development Tips","title":"Development Tips","text":"applications. To change this one can do","category":"page"},{"location":"devtips.html","page":"Development Tips","title":"Development Tips","text":"mount -o remount,size=1G /","category":"page"},{"location":"examples/sequence.html#Sequence-Example","page":"Sequence","title":"Sequence Example","text":"","category":"section"},{"location":"examples/sequence.html","page":"Sequence","title":"Sequence","text":"In this example we generate a 10 kHz sine wave on DAC channel 1 and also construct a sequence with a climbing offset every 5 periods. We receive this signal on ADC channel 1. To run this example connect the RedPitaya in the following way.","category":"page"},{"location":"examples/sequence.html","page":"Sequence","title":"Sequence","text":"(Image: RedPitaya)","category":"page"},{"location":"examples/sequence.html#Julia-Client","page":"Sequence","title":"Julia Client","text":"","category":"section"},{"location":"examples/sequence.html","page":"Sequence","title":"Sequence","text":"This and all other examples are located in the examples directory","category":"page"},{"location":"examples/sequence.html","page":"Sequence","title":"Sequence","text":"# Adapted from https://github.com/JuliaDocs/Documenter.jl/issues/499\nusing Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(open(f->read(f, String), \"../../../src/examples/julia/sequence.jl\"))\n```\n\"\"\")","category":"page"},{"location":"examples/sequence.html","page":"Sequence","title":"Sequence","text":"(Image: Simple Example Results)","category":"page"},{"location":"index.html#RedPitayaDAQServer","page":"Home","title":"RedPitayaDAQServer","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Advanced DAQ Tools for the RedPitaya (STEMlab 125-14)","category":"page"},{"location":"index.html#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This project contains software to be used with the STEMlab 125-14 device from RedPitaya. It allows for continuous generation and measurement of signals with up to 15.625 MS/s, which is not possible with the standard image of the RedPitaya. In addition, the software allows to synchronize a cluster of multiple RedPitayas. This project contains the following parts:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Alpine Linux image for the RedPitaya\nFPGA images for the 7010 and 7020\nLibrary written in C to interact with the FPGA image on the RedPitaya\nSCPI Server for accessing the functionality over TCP/IP\nSCPI Client to access the server","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The code is contained in this repository.","category":"page"},{"location":"index.html#License-/-Terms-of-Usage","page":"Home","title":"License / Terms of Usage","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The source code of this project is licensed under the MIT license. This implies that you are free to use, share, and adapt it. However, please give appropriate credit by citing the project.","category":"page"},{"location":"index.html#Contact","page":"Home","title":"Contact","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"If you have problems using the software, find mistakes, or have general questions please use the issue tracker to contact us.","category":"page"},{"location":"index.html#Contributors","page":"Home","title":"Contributors","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Tobias Knopp\nNiklas Hackelberg\nJonas Schumacher\nMatthias Gräser","category":"page"},{"location":"index.html#Credit","page":"Home","title":"Credit","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This package is partly based on work of Koheron [1] and Pavel Demin [2]","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"[1] https://www.koheron.com/blog/2016/11/29/red-pitaya-cluster [2] https://github.com/pavel-demin/red-pitaya-notes","category":"page"}]
}
