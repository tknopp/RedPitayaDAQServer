var documenterSearchIndex = {"docs":
[{"location":"generation.html#Signal-Generation","page":"Signal Generation","title":"Signal Generation","text":"","category":"section"},{"location":"generation.html","page":"Signal Generation","title":"Signal Generation","text":"2 FastDAC, 4 SlowDAC, possible waveforms","category":"page"},{"location":"generation.html#Sequences","page":"Signal Generation","title":"Sequences","text":"","category":"section"},{"location":"generation.html","page":"Signal Generation","title":"Signal Generation","text":"S_i(t) = a_i1w(t f_i1 varphi_i 1) + o_i + tildeo_i(t)  +sum_j=2^4a_ij sin(2pi f_ijt + varphi_i j)","category":"page"},{"location":"connections.html#Connections","page":"Connections","title":"Connections","text":"","category":"section"},{"location":"connections.html","page":"Connections","title":"Connections","text":"An overview of the extension connectors (see also here) is given in the following image","category":"page"},{"location":"connections.html","page":"Connections","title":"Connections","text":"(Image: Connectors)","category":"page"},{"location":"connections.html","page":"Connections","title":"Connections","text":"The project uses most but not all connections that are used in the original RedPitaya image. From the connector E2 only the analog inputs and outputs are used. From the connector E1 several pins are reserved for the following purposes:","category":"page"},{"location":"connections.html","page":"Connections","title":"Connections","text":"DIO0_P for the ADC and DAC trigger. Connect it with the master's DIO5_P to distribute the trigger signal to all RPs including the master. As long as the input is high, the DACs and ADCs are running.\nDIO1_P is the input for the watchdog (see configuration register section for further details)\nDIO2_P is used to acknowledge a received watchdog signal.\nDIO3_P can be set to high, to stop all DACs instantly.\nDIO4_P outputs a high for 10 ms after a 100 ms pause on low to provide an alive signal.\nDIO5_P can be set to high via the configuration register to provide the mutual trigger signal.\nDIO7_P, DIO7_N, DIO6_P, DIO6_N, DIO5_N, DIO4_N, DIO3_N, DIO2_N can be used as arbitrary outputs set via the server.","category":"page"},{"location":"installation.html#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation.html#Alpine-Linux-Image","page":"Installation","title":"Alpine Linux Image","text":"","category":"section"},{"location":"installation.html","page":"Installation","title":"Installation","text":"The RedPitayaDAQServer project uses a custom RedPitaya image that was derived from the red-pitaya-notes project. It consists of an Alpine Linux with some development tools installed. Additionally the image reserves the upper 128 MB of main memory for the FPGA, which is used as a buffer for recording the data from the fast ADCs. The linux image can be downloaded here. Just unzip the zip file and copy the content on an empty SD card that is formatted in FAT32. When you insert the SD card into the RedPitaya you should see a blinking LED.","category":"page"},{"location":"installation.html#Setting-Up-the-Server","page":"Installation","title":"Setting Up the Server","text":"","category":"section"},{"location":"installation.html","page":"Installation","title":"Installation","text":"Next you need to install the server application. To this end, connect the RedPitaya to you local network and access the device via ssh:","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"ssh root@rp-f?????.local","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"where ????? is the ID that is printed on the RedPitaya. The default password is root. After logging into the RedPitaya go to the folder","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"/root/apps/","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"and clone the RedPitayaDAQServer project:","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"git clone https://github.com/tknopp/RedPitayaDAQServer","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"Sometimes you might need to make the file system writable by entering","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"mount -o remount,rw /dev/mmcblk0p1","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"Then cd into RedPitayaDAQServer","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"cd /root/apps/RedPitayaDAQServer","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"and enter make. This will compile the library, the server, and some example applications. After you restart the RedPitaya the DAQ server will automatically run and you can access it via TCP.","category":"page"},{"location":"installation.html#Setting-Up-the-Julia-Client-Library","page":"Installation","title":"Setting Up the Julia Client Library","text":"","category":"section"},{"location":"installation.html","page":"Installation","title":"Installation","text":"For the Julia client library you need to install RedPitayaDAQServer within Julia. To this end download Julia 1.5 or later and go into the package manager mode by intering ]. Then there are two options to install the client library.","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"add RedPitayaDAQServer:src/client/julia\ndev RedPitayaDAQServer:src/client/julia","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"The first is installing the currently published version. The second is installing in development mode and put the files to ~/dev/RedPitayaDAQServer/ where you can the also modify the files, which is handy when trying out the examples. Right now we recommend to dev the package. You need to git pull from ~/dev/RedPitayaDAQServer/ if you want to get updates, i.e. Julia will not update developed packages automatically.","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"The client library is not an executable data acquisition program, but it can be used to implement one. The library encapsulates the communication with the server and implements various optimizations. As the communication with the server is language agnostic and one could therefore implement their own client in a different language. The Julia reference client library found in src/client/julia, the SCPI commands and the sections on the signal acquisition and generation are starting points for such a custom client.d","category":"page"},{"location":"examples/waveforms.html#Waveforms-Example","page":"Waveforms","title":"Waveforms Example","text":"","category":"section"},{"location":"examples/waveforms.html","page":"Waveforms","title":"Waveforms","text":"In this example we generate different signals with a base frequency of 10 kHz on fast DAC channel 1 and receive the same signals on the fast ADC. To run this example connect the RedPitaya in the following way.","category":"page"},{"location":"examples/waveforms.html","page":"Waveforms","title":"Waveforms","text":"(Image: Cluster)","category":"page"},{"location":"examples/waveforms.html#Julia-Client","page":"Waveforms","title":"Julia Client","text":"","category":"section"},{"location":"examples/waveforms.html","page":"Waveforms","title":"Waveforms","text":"This and all other examples are located in the examples directory","category":"page"},{"location":"examples/waveforms.html","page":"Waveforms","title":"Waveforms","text":"# Adapted from https://github.com/JuliaDocs/Documenter.jl/issues/499\nusing Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(open(f->read(f, String), \"../../../src/examples/julia/waveforms.jl\"))\n```\n\"\"\")","category":"page"},{"location":"examples/waveforms.html","page":"Waveforms","title":"Waveforms","text":"(Image: Simple Example Results)","category":"page"},{"location":"examples/simple.html#Simple-Example","page":"Simple","title":"Simple Example","text":"","category":"section"},{"location":"examples/simple.html","page":"Simple","title":"Simple","text":"In the first example we generate a sinus signal of frequency 10 kHz on fast DAC channel 1 and receive the same signal on the fast ADC. To run this example connect the RedPitaya in the following way.","category":"page"},{"location":"examples/simple.html","page":"Simple","title":"Simple","text":"(Image: Cluster)","category":"page"},{"location":"examples/simple.html#Julia-Client","page":"Simple","title":"Julia Client","text":"","category":"section"},{"location":"examples/simple.html","page":"Simple","title":"Simple","text":"This and all other examples are located in the examples directory","category":"page"},{"location":"examples/simple.html","page":"Simple","title":"Simple","text":"# Adapted from https://github.com/JuliaDocs/Documenter.jl/issues/499\nusing Markdown\nMarkdown.parse(\"\"\"\n```julia\n$(open(f->read(f, String), \"../../../src/examples/julia/simple.jl\"))\n```\n\"\"\")","category":"page"},{"location":"examples/simple.html","page":"Simple","title":"Simple","text":"(Image: Simple Example Results)","category":"page"},{"location":"architecture.html#Architecture","page":"Architecture","title":"Architecture","text":"","category":"section"},{"location":"architecture.html","page":"Architecture","title":"Architecture","text":"The RedPitayaDAQServer project is implemented as a distributed system in which one client connects to a cluster of RedPitaya boards. The project has four software components:","category":"page"},{"location":"architecture.html","page":"Architecture","title":"Architecture","text":"FPGA image running the RedPitayas\nC library encapsulating access to the FPGA image\nServer running on the CPU of the RedPitayas\nClient Julia reference library ","category":"page"},{"location":"architecture.html","page":"Architecture","title":"Architecture","text":"The FPGA image is responsible for generating and acquiring sychronized out- and input signals. The server acts as an intermediary to the FPGA over a TCP/IP connection, which allows remote clients to configure the FPGA image and retrieve samples. Furthermore, the server also maintains a thread that takes part in signal generation.","category":"page"},{"location":"architecture.html","page":"Architecture","title":"Architecture","text":"The Julia client library can be used to implement a data acqusition client application, which controls a (cluster of) RedPitaya(s). This Julia library acts as a reference, but in principle it is possible to write clients in any programming language, as the communication is language agnostic.","category":"page"},{"location":"architecture.html#Communication","page":"Architecture","title":"Communication","text":"","category":"section"},{"location":"architecture.html","page":"Architecture","title":"Architecture","text":"The various components of the distributed system communicate over different interfaces. Communication within a RedPitaya is based on memory-mapped I/O, while communication between the server and a client is based on a TCP/IP connection, usually over Ethernet. Lastly communication between RedPitayas is limited to signals distributed over cables as described in Cluster.","category":"page"},{"location":"architecture.html#FPGA-and-CPU","page":"Architecture","title":"FPGA and CPU","text":"","category":"section"},{"location":"architecture.html","page":"Architecture","title":"Architecture","text":"The FPGA image is directly connected to certain memory regions that can be memory mapped on the CPU of the RedPitaya. And both the CPU and the FPGA image access the reserved main memory region. The C library rp-daq-lib located in src/lib/ encapsulates this memory access into a convenient C library. It is possible to use this C library directly when no communication with the host system is required, i.e. if one wants to write the acquired data into a file. When making changes to the FPGA image one may need to adapt the rp-daq-lib C library.","category":"page"},{"location":"architecture.html","page":"Architecture","title":"Architecture","text":"The server itself uses the rp-daq-lib library to interface with the FPGA image.","category":"page"},{"location":"architecture.html#Client-and-Server","page":"Architecture","title":"Client and Server","text":"","category":"section"},{"location":"architecture.html","page":"Architecture","title":"Architecture","text":"The server has two TCP sockets to which a client needs to connect. The first is the command socket on port 5025 and the second is teh data socket on port 5026. Over the former, a client can send SCPI commands to the server and receive replies, while the latter is used for sending binary data such as the samples acquired by the ADCs.","category":"page"},{"location":"architecture.html","page":"Architecture","title":"Architecture","text":"SCPI commands are ASCII strings, such as RP:ADC:DECimation, which the server translates into C function calls. As an example these calls could invoke a function of the rp-daq-lib to set the decimation of the acqusition or instruct the server to transmit data over the data socket. A list of the available SCPI commands can be found here.","category":"page"},{"location":"architecture.html","page":"Architecture","title":"Architecture","text":"At any point a server is only connected to one client and establishing a new connection stops any current signal generation and acquisition.","category":"page"},{"location":"fpga.html#FPGA-Development","page":"FPGA Development","title":"FPGA Development","text":"","category":"section"},{"location":"fpga.html","page":"FPGA Development","title":"FPGA Development","text":"There may be needs to change the FPGA image. The following explains how this can be done.","category":"page"},{"location":"fpga.html#Preparation","page":"FPGA Development","title":"Preparation","text":"","category":"section"},{"location":"fpga.html","page":"FPGA Development","title":"FPGA Development","text":"If you want to make changes to the FPGA design, you need to install Vivado 2017.2. More infos for setting up a development machine we refer to the following recource.","category":"page"},{"location":"fpga.html","page":"FPGA Development","title":"FPGA Development","text":"After following the installation steps, you need to clone the repository into a directory of your choice and then regenerate the IP cores  and the project by running","category":"page"},{"location":"fpga.html","page":"FPGA Development","title":"FPGA Development","text":"./make_fpga_project.sh.","category":"page"},{"location":"fpga.html","page":"FPGA Development","title":"FPGA Development","text":"Afterwards you can start Vivado and open the recreated project in ./build/fpga/firmware/RedPitayaDAQServer.xpr. Apply the changes you need and then create the bitfile by using 'Flow -> Generate Bitstream'. This runs the synthesis and implementation steps and output the Bitfile to ./build/fpga/firmware/RedPitayaDAQServer.runs/impl_1/system_wrapper.bit. Please note, that you have to create both the master and the slave image. This can be done by simply changing the value of xlconstantmasterslave_. A '1' denotes the use of the internal ADC clock and is used for the master. A '0' selects the clock distributed via the daisy chain connectors and is therefore used for the slaves.","category":"page"},{"location":"fpga.html","page":"FPGA Development","title":"FPGA Development","text":"(Image: Clock selection in the blockdesign)","category":"page"},{"location":"fpga.html","page":"FPGA Development","title":"FPGA Development","text":"After creating the respective bitfile you need to copy it to your Red Pitayas. You can use","category":"page"},{"location":"fpga.html","page":"FPGA Development","title":"FPGA Development","text":"scp ./build/fpga/firmware/RedPitayaDAQServer.runs/impl_1/system_wrapper.bin root@<IP>:/root/RedPitayaDAQServer/bitfiles/<master,slave>.bin","category":"page"},{"location":"fpga.html","page":"FPGA Development","title":"FPGA Development","text":"for this. Set your IP and master/slave accordingly.","category":"page"},{"location":"fpga.html","page":"FPGA Development","title":"FPGA Development","text":"Since using git with Vivado can be annoying here are some hints how you can make your changes ready for git:","category":"page"},{"location":"fpga.html","page":"FPGA Development","title":"FPGA Development","text":"If you only changed some stuff in the blockdesign, you just have to export the blockdesign to ./src/fpga/bd by using 'File -> Export -> Export Block Design' in Vivado.\nChanges to the project settings have to be done in ./src/fpga/build.tcl in order to not lose the ability to recreate your changed project.\nFor your own IP cores, just create a new directory in ./src/fpga/cores and copy and adapt the core_config.tcl of another core. Afterwards re-run make_cores.tcl.","category":"page"},{"location":"acquisition.html#Data-Acqusition","page":"Data Acquisition","title":"Data Acqusition","text":"","category":"section"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"The data acqusition of the RedPitayaDAQServer project is based on two data flows to and from the upper 128 MB of the RedPitaya memory. This memory region acts as a ring buffer for the acquired samples and can be queried by clients using SCPI commands.","category":"page"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"Once triggered to start via the master trigger, each FPGA in a cluster continously writes the sampled signals into their respective buffers. Both ADC channels on a RedPitaya are written to the buffer at the same time and the 16-bit samples are concatenated into one 32-bit value. The sampling rate of the system can be adjusted by setting a decimation parameter. Decimation is realized by using a CIC filter.","category":"page"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"Internally the FPGA keeps track of a 64-bit writepointer register pointing into the ring buffer and increments this value with each new sample pair. Additionally the writepointer also counts the number of buffer overflows. As the size of the buffer region is a power of two, the lower 25 bits of the writepointer are the buffer location and the remaining bits are the overflow counter. The writepointer can be directly interpreted as the total number of samples written since the data acquisition was started. The current writepointer value can be queried by a SCPI command.","category":"page"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"In the SCPI commands for sample retrieval a client can supply a similar pointer, a readpointer, to the server together with the number of samples to retrieve. The server then extracts the buffer position from the readpointer and transmits the requested amount of samples over the data socket. This transmission happens either way, even if the samples are overwritten. However, the server uses the whole readpointer, including the buffer overflows, to check if the requested samples were overwritten.","category":"page"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"If the distance between the write- and readpointer is larger than the buffer size the overflow status flag is set. If during the transmission the requested samples are overwritten the corrupted flag is set. These flags can be queried individually or together in a status byte via SCPI commands.","category":"page"},{"location":"acquisition.html#Considerations-for-Sample-Retrieval","page":"Data Acquisition","title":"Considerations for Sample Retrieval","text":"","category":"section"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"There are several things to consider when attempting to retrieve samples at a high sampling rate, larger cluster sizes or for longer periods of time. Most of the following points were implemented/considered in the Julia reference implementation, but would become relevant when implementing new clients.","category":"page"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"As the server will always transmit samples just based on the buffer position of a readpointer, if a client wants to only receive certain samples it needs to wait for them to exist in the buffer. This requires querying the writepointer until it is larger than the desired readpointer.","category":"page"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"If the number of requested samples is larger than the buffer, the sample should be requested in smaller chunks as the server would otherwise return samples that were not written yet. In a cluster scenario the i-th chunk should be requested from all RedPitayas in the cluster before requesting the next chunk.","category":"page"},{"location":"acquisition.html#Considerations-for-Frame-Retrieval/Julia-Client","page":"Data Acquisition","title":"Considerations for Frame Retrieval/Julia Client","text":"","category":"section"},{"location":"acquisition.html","page":"Data Acquisition","title":"Data Acquisition","text":"Producer/Consumer","category":"page"},{"location":"cluster.html#Cluster","page":"Cluster","title":"Cluster","text":"","category":"section"},{"location":"cluster.html","page":"Cluster","title":"Cluster","text":"The RedPitayaDAQServer allows to use multiple RedPitayas in a fully synchronized fashion. One of the RedPitayas will act as the master and distribute its clock to all other RedPitayas acting as slaves.","category":"page"},{"location":"cluster.html#Prerequisites","page":"Cluster","title":"Prerequisites","text":"","category":"section"},{"location":"cluster.html","page":"Cluster","title":"Cluster","text":"Unfortunately, the STEMlab 125-4 does not allow cluster synchronization without hardware modifications.   It is therefore necessary to resolder all slaves according to this documentation. The required mode for this project is 'Directly from FPGA'. The heatsink has to be removed temporarily in order to unsolder the two resistor below it. In the following image you can see the new position of the 0 Ohm 0402 resistors. Since they get lost easily, make sure you have some in stock.","category":"page"},{"location":"cluster.html","page":"Cluster","title":"Cluster","text":"(Image: Cluster)","category":"page"},{"location":"cluster.html#Connections","page":"Cluster","title":"Connections","text":"","category":"section"},{"location":"cluster.html","page":"Cluster","title":"Cluster","text":"To run a cluster of RedPitayas one needs to connect the devices using different cables. An exemplary cluster with 3 devices is shown in the following image.","category":"page"},{"location":"cluster.html","page":"Cluster","title":"Cluster","text":"(Image: Cluster)","category":"page"},{"location":"cluster.html","page":"Cluster","title":"Cluster","text":"The clock is distributed from the master to the first slave via an SATA cable (green). Additional slaves can be used by connecting the next slave to the previous one. Additionally all slaves have connection from +3.3 Volt to DIO0_N.","category":"page"},{"location":"cluster.html","page":"Cluster","title":"Cluster","text":"In order to send a mutual trigger signal for starting the acquisition and the signal generation, you also have to connect the master's DIO5_P pin (see link) with the DIO0_P pin of all devices including the master.","category":"page"},{"location":"client.html#Client","page":"Client","title":"Client","text":"","category":"section"},{"location":"client.html","page":"Client","title":"Client","text":"This page contains documentation of the public API of the Julia client. In the Julia REPL one can access this documentation by entering the help mode with ? and then writing the function for which the documentation should be shown.","category":"page"},{"location":"client.html#Connection-and-Communication","page":"Client","title":"Connection and Communication","text":"","category":"section"},{"location":"client.html","page":"Client","title":"Client","text":"RedPitayaDAQServer.RedPitaya\nRedPitayaDAQServer.RedPitaya(::String, ::Int64, ::Bool)\nRedPitayaDAQServer.send(::RedPitaya, ::String)\nRedPitayaDAQServer.query\nRedPitayaDAQServer.receive\nRedPitayaDAQServer.RedPitayaCluster\nRedPitayaDAQServer.RedPitayaCluster(::Vector{String}, ::Int64)\nRedPitayaDAQServer.master","category":"page"},{"location":"client.html#RedPitayaDAQServer.RedPitaya","page":"Client","title":"RedPitayaDAQServer.RedPitaya","text":"RedPitaya\n\nStruct representing a connection to a RedPitayaDAQServer.\n\nContains the sockets used for communication and connection related metadata. Also contains fields for  client specific concepts such as periods, frames and calibration values. \n\n\n\n\n\n","category":"type"},{"location":"client.html#RedPitayaDAQServer.RedPitaya-Tuple{String,Int64,Bool}","page":"Client","title":"RedPitayaDAQServer.RedPitaya","text":"RedPitaya(ip [, port = 5025, isMaster = false])\n\nConstruct a RedPitaya.\n\nDuring the construction the connection is established and the calibration values are loaded from the RedPitayas EEPROM. Throws an error if a timeout occurs while attempting to connect.\n\nExamples\n\njulia> rp = RedPitaya(\"192.168.1.100\");\n\njulia> decimation(rp, 8)\n\njulia> decimation(rp)\n8\n\n\n\n\n\n","category":"method"},{"location":"client.html#Sockets.send-Tuple{RedPitaya,String}","page":"Client","title":"Sockets.send","text":"send(rp::RedPitaya, cmd::String)\n\nSend a command to the RedPitaya. Appends delimiter.\n\n\n\n\n\n","category":"method"},{"location":"client.html#RedPitayaDAQServer.query","page":"Client","title":"RedPitayaDAQServer.query","text":"query(rp::RedPitaya, cmd [, timeout = 5.0, N = 100])\n\nSend a query to the RedPitaya command socket. Return reply as String.\n\nWaits for timeout seconds and checks every timeout/N seconds.\n\nSee also receive.\n\n\n\n\n\nquery(rp::RedPitaya, cmd, T::Type [timeout = 5.0, N = 100])\n\nSend a query to the RedPitaya. Parse reply as T.\n\nWaits for timeout seconds and checks every timeout/N seconds.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.receive","page":"Client","title":"RedPitayaDAQServer.receive","text":"receive(rp::RedPitaya)\n\nReceive a String from the RedPitaya command socket. Reads until a whole line is received\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.RedPitayaCluster","page":"Client","title":"RedPitayaDAQServer.RedPitayaCluster","text":"RedPitayaCluster\n\nStruct representing a cluster of RedPitayas. Such a cluster should share a common clock and master trigger.\n\nThe structure implements the indexing and iterable interfaces.\n\n\n\n\n\n","category":"type"},{"location":"client.html#RedPitayaDAQServer.RedPitayaCluster-Tuple{Array{String,1},Int64}","page":"Client","title":"RedPitayaDAQServer.RedPitayaCluster","text":"RedPitayaCluster(hosts::Vector{String} [, port = 5025])\n\nConstruct a RedPitayaCluster.\n\nDuring the construction the first host is labelled the master RedPitaya of a cluster and all RedPitayas are set to using the EXTERNAL trigger mode.\n\nSee also RedPitaya, master.\n\nExamples\n\njulia> rpc = RedPitayaCluster([\"192.168.1.100\", \"192.168.1.101\"]);\n\njulia> rp = master(rpc)\n\njulia> rp == rpc[1]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"client.html#RedPitayaDAQServer.master","page":"Client","title":"RedPitayaDAQServer.master","text":"master(rpc::RedPitayaCluster)\n\nReturn the master RedPitaya of the cluster.\n\n\n\n\n\n","category":"function"},{"location":"client.html#ADC-Configuration","page":"Client","title":"ADC Configuration","text":"","category":"section"},{"location":"client.html","page":"Client","title":"Client","text":"RedPitayaDAQServer.TriggerMode\nRedPitayaDAQServer.triggerMode\nRedPitayaDAQServer.triggerMode!\nRedPitayaDAQServer.keepAliveReset\nRedPitayaDAQServer.keepAliveReset!\nRedPitayaDAQServer.decimation\nRedPitayaDAQServer.decimation!\nRedPitayaDAQServer.numChan\nRedPitayaDAQServer.samplesPerPeriod\nRedPitayaDAQServer.samplesPerPeriod!\nRedPitayaDAQServer.periodsPerFrame\nRedPitayaDAQServer.periodsPerFrame!","category":"page"},{"location":"client.html#RedPitayaDAQServer.TriggerMode","page":"Client","title":"RedPitayaDAQServer.TriggerMode","text":"TriggerMode\n\nRepresent the different trigger modes the FPGA image can have.\n\nSee triggerMode, triggerMode!.\n\n\n\n\n\n","category":"type"},{"location":"client.html#RedPitayaDAQServer.triggerMode","page":"Client","title":"RedPitayaDAQServer.triggerMode","text":"triggerMode(rpc::RedPitayaCluster)\n\nAs with single RedPitaya, but applied to only the master.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.triggerMode!","page":"Client","title":"RedPitayaDAQServer.triggerMode!","text":"triggerMode(rp::RedPitaya, mode::String)\n\nSet the trigger mode of the RedPitaya. Valid values are \"INTERNAL\" or \"EXTERNAL\".\n\n\n\n\n\ntriggerMode(rp::RedPitaya, mode::String)\n\nSet the trigger mode of the RedPitaya.\n\n\n\n\n\n  triggerMode!(rpc::RedPitayaCluster, value)\n\nAs with single RedPitaya, but applied to all RedPitayas in a cluster.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.keepAliveReset","page":"Client","title":"RedPitayaDAQServer.keepAliveReset","text":"keepAliveReset(rp::RedPitaya)\n\nDetermine whether the keepAliveReset is set.\n\n\n\n\n\nkeepAliveReset(rpc::RedPitayaCluster)\n\nAs with single RedPitaya, but applied to only the master.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.keepAliveReset!","page":"Client","title":"RedPitayaDAQServer.keepAliveReset!","text":"keepAliveReset!(rp::RedPitaya, val::Bool)\n\nSet the keepAliveReset to val.\n\n\n\n\n\n  keepAliveReset!(rpc::RedPitayaCluster, value)\n\nAs with single RedPitaya, but applied to all RedPitayas in a cluster.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.decimation","page":"Client","title":"RedPitayaDAQServer.decimation","text":"decimation(rp::RedPitaya)\n\nReturn the decimation of the RedPitaya.\n\nExamples\n\njulia> rp = RedPitaya(\"192.168.1.100\");\n\njulia> decimation!(rp, 8)\n\njulia> decimation(rp)\n8\n\n\n\n\n\ndecimation(rpc::RedPitayaCluster)\n\nAs with single RedPitaya, but applied to only the master.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.decimation!","page":"Client","title":"RedPitayaDAQServer.decimation!","text":"decimation!(rp::RedPitaya, dec)\n\nSet the decimation of the RedPitaya.\n\nExamples\n\njulia> decimation!(rp, 8)\n\njulia> decimation(rp)\n8\n\n\n\n\n\n  decimation!(rpc::RedPitayaCluster, value)\n\nAs with single RedPitaya, but applied to all RedPitayas in a cluster.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.numChan","page":"Client","title":"RedPitayaDAQServer.numChan","text":"numChan(rp::RedPitaya)\n\nReturn the number of ADC channel of a RedPitaya.\n\n\n\n\n\nnumChan(rpc::RedPitayaCluster)\n\nReturn the number of ADC channel in cluser rpc.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.samplesPerPeriod","page":"Client","title":"RedPitayaDAQServer.samplesPerPeriod","text":"samplesPerPeriod(rp::RedPitaya)\n\nReturn the number of samples per period.\n\nExample\n\njulia> samplesPerPeriod!(rp, 256)\n\njulia> samplesPerPeriod(rp)\n256\n\n\n\n\n\n\nsamplesPerPeriod(rpc::RedPitayaCluster)\n\nAs with single RedPitaya, but applied to only the master.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.samplesPerPeriod!","page":"Client","title":"RedPitayaDAQServer.samplesPerPeriod!","text":"samplesPerPeriod!(rp::RedPitaya, value)\n\nSet the number of samples per period.\n\nExample\n\njulia> samplesPerPeriod!(rp, 256)\n\njulia> samplesPerPeriod(rp)\n256\n\n\n\n\n\n\n  samplesPerPeriod!(rpc::RedPitayaCluster, value)\n\nAs with single RedPitaya, but applied to all RedPitayas in a cluster.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.periodsPerFrame","page":"Client","title":"RedPitayaDAQServer.periodsPerFrame","text":"periodsPerFrame(rp::RedPitaya)\n\nReturn the number of periods per frame.\n\nExample\n\njulia> periodsPerFrame!(rp, 16)\n\njulia> periodsPerFrame(rp)\n16\n\n\n\n\n\n\nperiodsPerFrame(rpc::RedPitayaCluster)\n\nAs with single RedPitaya, but applied to only the master.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.periodsPerFrame!","page":"Client","title":"RedPitayaDAQServer.periodsPerFrame!","text":"periodsPerFrame(rp::RedPitaya, value)\n\nSet the number of periods per frame.\n\nExample\n\njulia> periodsPerFrame!(rp, 16)\n\njulia> periodsPerFrame(rp)\n16\n\n\n\n\n\n\n  periodsPerFrame!(rpc::RedPitayaCluster, value)\n\nAs with single RedPitaya, but applied to all RedPitayas in a cluster.\n\n\n\n\n\n","category":"function"},{"location":"client.html#DAC-Configuration","page":"Client","title":"DAC Configuration","text":"","category":"section"},{"location":"client.html","page":"Client","title":"Client","text":"RedPitayaDAQServer.amplitudeDAC\nRedPitayaDAQServer.amplitudeDAC!\nRedPitayaDAQServer.offsetDAC\nRedPitayaDAQServer.offsetDAC!\nRedPitayaDAQServer.frequencyDAC\nRedPitayaDAQServer.frequencyDAC!\nRedPitayaDAQServer.phaseDAC\nRedPitayaDAQServer.phaseDAC!\nRedPitayaDAQServer.jumpSharpnessDAC\nRedPitayaDAQServer.jumpSharpnessDAC!\nRedPitayaDAQServer.SignalType\nRedPitayaDAQServer.signalTypeDAC\nRedPitayaDAQServer.signalTypeDAC!\nRedPitayaDAQServer.numSeqChan\nRedPitayaDAQServer.numSeqChan!\nRedPitayaDAQServer.samplesPerStep\nRedPitayaDAQServer.samplesPerStep!\nRedPitayaDAQServer.stepsPerFrame!\nRedPitayaDAQServer.AbstractSequence\nRedPitayaDAQServer.appendSequence!\nRedPitayaDAQServer.prepareSequence!\nRedPitayaDAQServer.clearSequences!\nRedPitayaDAQServer.popSequence!\nRedPitayaDAQServer.length(::AbstractSequence)\nRedPitayaDAQServer.start\nRedPitayaDAQServer.ArbitrarySequence\nRedPitayaDAQServer.ArbitrarySequence(lut, enable, repetitions, upSteps, upTotalSteps, downSteps, downTotalSteps, reset)","category":"page"},{"location":"client.html#RedPitayaDAQServer.amplitudeDAC","page":"Client","title":"RedPitayaDAQServer.amplitudeDAC","text":"amplitudeDAC(rp::RedPitaya, channel, component)\n\nReturn the amplitude of composite waveform component for channel.\n\nSee amplitudeDAC!.\n\nExamples\n\njulia> amplitudeDAC!(rp, 1, 1, 0.5);\n\njulia> amplitudeDAC(rp, 1, 1)\n0.5\n\n\n\n\n\namplitudeDAC(rpc::RedPitayaCluster, chan::Integer, component::Integer)\n\nAs with single RedPitaya. The chan index refers to the total channel available in a cluster, two per RedPitaya. For example channel 4 would refer to the second channel of the second RedPitaya. \n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.amplitudeDAC!","page":"Client","title":"RedPitayaDAQServer.amplitudeDAC!","text":"amplitudeDAC!(rp::RedPitaya, channel, component, value)\n\nSet the amplitude of composite waveform component for channel.\n\nSee amplitudeDAC.\n\nExamples\n\njulia> amplitudeDAC!(rp, 1, 1, 0.5);\n\njulia> amplitudeDAC(rp, 1, 1)\n0.5\n\n\n\n\n\namplitudeDAC!(rpc::RedPitayaCluster, chan::Integer, component::Integer, value)\n\nAs with single RedPitaya. The chan index refers to the total channel available in a cluster, two per RedPitaya. For example channel 4 would refer to the second channel of the second RedPitaya.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.offsetDAC","page":"Client","title":"RedPitayaDAQServer.offsetDAC","text":"offsetDAC(rp::RedPitaya, channel)\n\nReturn the offset for channel.\n\nSee offsetDAC!.\n\nExamples\n\njulia> offsetDAC!(rp, 1, 0.2);\n\njulia> offsetDAC(rp, 1)\n0.2\n\n\n\n\n\noffsetDAC(rpc::RedPitayaCluster, chan::Integer)\n\nAs with single RedPitaya. The chan index refers to the total channel available in a cluster, two per RedPitaya. For example channel 4 would refer to the second channel of the second RedPitaya.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.offsetDAC!","page":"Client","title":"RedPitayaDAQServer.offsetDAC!","text":"offsetDAC!(rp::RedPitaya, channel, value)\n\nSet the offset for channel.\n\nSee offsetDAC.\n\nExamples\n\njulia> offsetDAC!(rp, 1, 0.2);\n\njulia> offsetDAC(rp, 1)\n0.2\n\n\n\n\n\noffsetDAC!(rpc::RedPitayaCluster, chan::Integer, value)\n\nAs with single RedPitaya. The chan index refers to the total channel available in a cluster, two per RedPitaya. For example channel 4 would refer to the second channel of the second RedPitaya.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.frequencyDAC","page":"Client","title":"RedPitayaDAQServer.frequencyDAC","text":"frequencyDAC(rp::RedPitaya, channel, component)\n\nReturn the frequency of composite waveform component for channel.\n\nSee frequencyDAC!.\n\nExamples\n\njulia> frequencyDAC!(rp, 1, 1, 2400);\n\njulia> frequencyDAC(rp, 1, 1)\n2400\n\n\n\n\n\nfrequencyDAC(rpc::RedPitayaCluster, chan::Integer, component::Integer)\n\nAs with single RedPitaya. The chan index refers to the total channel available in a cluster, two per RedPitaya. For example channel 4 would refer to the second channel of the second RedPitaya. \n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.frequencyDAC!","page":"Client","title":"RedPitayaDAQServer.frequencyDAC!","text":"frequencyDAC!(rp::RedPitaya, channel, component, value)\n\nSet the frequency of composite waveform component for channel.\n\nSee frequencyDAC.\n\nExamples\n\njulia> frequencyDAC!(rp, 1, 1, 2400);\n\njulia> frequencyDAC(rp, 1, 1)\n2400\n\n\n\n\n\nfrequencyDAC!(rpc::RedPitayaCluster, chan::Integer, component::Integer, value)\n\nAs with single RedPitaya. The chan index refers to the total channel available in a cluster, two per RedPitaya. For example channel 4 would refer to the second channel of the second RedPitaya.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.phaseDAC","page":"Client","title":"RedPitayaDAQServer.phaseDAC","text":"phaseDAC(rp::RedPitaya, channel, component)\n\nReturn the phase of composite waveform component for channel.\n\nSee phaseDAC!.\n\nExamples\n\njulia> phaseDAC!(rp, 1, 1, 0.0);\n\njulia> phaseDAC(rp, 1, 0.0)\n0.0\n\n\n\n\n\nphaseDAC(rpc::RedPitayaCluster, chan::Integer, component::Integer)\n\nAs with single RedPitaya. The chan index refers to the total channel available in a cluster, two per RedPitaya. For example channel 4 would refer to the second channel of the second RedPitaya. \n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.phaseDAC!","page":"Client","title":"RedPitayaDAQServer.phaseDAC!","text":"phaseDAC!(rp::RedPitaya, channel, component, value)\n\nSet the phase of composite waveform component for channel.\n\nSee phaseDAC.\n\nExamples\n\njulia> phaseDAC!(rp, 1, 1, 0.0);\n\njulia> phaseDAC(rp, 1, 0.0)\n0.0\n\n\n\n\n\nphaseDAC!(rpc::RedPitayaCluster, chan::Integer, component::Integer, value)\n\nAs with single RedPitaya. The chan index refers to the total channel available in a cluster, two per RedPitaya. For example channel 4 would refer to the second channel of the second RedPitaya.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.jumpSharpnessDAC","page":"Client","title":"RedPitayaDAQServer.jumpSharpnessDAC","text":"jumpSharpnessDAC(rp::RedPitaya, channel, value)\n\nReturn the jumpSharpness of composite waveform for channel.\n\nSee jumpSharpnessDAC!.\n\nExamples\n\njulia> jumpSharpnessDAC!(rp, 1, 0.01);\n\njulia> jumpSharpnessDAC(rp, 1)\n0.01\n\n\n\n\n\njumpSharpnessDAC(rpc::RedPitayaCluster, chan::Integer)\n\nAs with single RedPitaya. The chan index refers to the total channel available in a cluster, two per RedPitaya. For example channel 4 would refer to the second channel of the second RedPitaya.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.jumpSharpnessDAC!","page":"Client","title":"RedPitayaDAQServer.jumpSharpnessDAC!","text":"jumpSharpnessDAC!(rp::RedPitaya, channel, value)\n\nSet the jumpSharpness of composite waveform for channel.\n\nSee jumpSharpnessDAC.\n\nExamples\n\njulia> jumpSharpnessDAC!(rp, 1, 0.01);\n\njulia> jumpSharpnessDAC(rp, 1)\n0.01\n\n\n\n\n\njumpSharpnessDAC!(rpc::RedPitayaCluster, chan::Integer, value)\n\nAs with single RedPitaya. The chan index refers to the total channel available in a cluster, two per RedPitaya. For example channel 4 would refer to the second channel of the second RedPitaya.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.SignalType","page":"Client","title":"RedPitayaDAQServer.SignalType","text":"SignalType\n\nRepresent the different types of signals the fast DAC can have.\n\nSee signalTypeDAC, signalTypeDAC!.\n\n\n\n\n\n","category":"type"},{"location":"client.html#RedPitayaDAQServer.signalTypeDAC","page":"Client","title":"RedPitayaDAQServer.signalTypeDAC","text":"signalTypeDAC!(rp::RedPitaya, channel, value)\n\nReturn the signalType of composite waveform for channel.\n\nSee signalTypeDAC!.\n\nExamples\n\njulia> signalTypeDAC!(rp, 1, SINE);\n\njulia> signalTypeDAC(rp, 1)\nSINE\n\n\n\n\n\nsignalTypeDAC(rpc::RedPitayaCluster, chan::Integer)\n\nAs with single RedPitaya. The chan index refers to the total channel available in a cluster, two per RedPitaya. For example channel 4 would refer to the second channel of the second RedPitaya.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.signalTypeDAC!","page":"Client","title":"RedPitayaDAQServer.signalTypeDAC!","text":"signalTypeDAC!(rp::RedPitaya, channel, value)\n\nSet the signalType of composite waveform for channel.\n\nSee signalTypeDAC.\n\nExamples\n\njulia> signalTypeDAC!(rp, 1, SINE);\n\njulia> signalTypeDAC(rp, 1)\nSINE\n\n\n\n\n\nsignalTypeDAC!(rpc::RedPitayaCluster, chan::Integer, value)\n\nAs with single RedPitaya. The chan index refers to the total channel available in a cluster, two per RedPitaya. For example channel 4 would refer to the second channel of the second RedPitaya.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.numSeqChan","page":"Client","title":"RedPitayaDAQServer.numSeqChan","text":"numSeqChan(rp::RedPitaya)\n\nReturn the number of sequence channel.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.numSeqChan!","page":"Client","title":"RedPitayaDAQServer.numSeqChan!","text":"numSeqChan(rp::RedPitaya, value)\n\nSet the number of sequence channel. Valid values are between 1 and 4.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.samplesPerStep","page":"Client","title":"RedPitayaDAQServer.samplesPerStep","text":"samplesPerStep(rp::RedPitaya)\n\nReturn the number of samples per sequence step.\n\n\n\n\n\nsamplesPerStep(rpc::RedPitayaCluster)\n\nAs with single RedPitaya, but applied to only the master.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.samplesPerStep!","page":"Client","title":"RedPitayaDAQServer.samplesPerStep!","text":"samplesPerStep!(rp::RedPitaya, value::Integer)\n\nSet the number of samples per sequence step.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.stepsPerFrame!","page":"Client","title":"RedPitayaDAQServer.stepsPerFrame!","text":"stepsPerFrame!(rp::RedPitaya, stepsPerFrame)\n\nSet the number of samples per steps s.t. stepsPerFrame sequence steps in a frame.\n\nSee samplesPerPeriod!, periodsPerFrame!, samplesPerStep!.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.AbstractSequence","page":"Client","title":"RedPitayaDAQServer.AbstractSequence","text":"AbstractSequence\n\nAbstract struct of client-side representation of a sequence.\n\nSee appendSequence!, prepareSequence!, ArbitrarySequence.\n\n\n\n\n\n","category":"type"},{"location":"client.html#RedPitayaDAQServer.appendSequence!","page":"Client","title":"RedPitayaDAQServer.appendSequence!","text":"appendSequence!(rp::RedPitaya, seq::AbstractSequence)\n\nTransmit the client-side representation seq to the server and append it to the current list of sequences.\n\nSee prepareSequence!, clearSequences!.\n\n\n\n\n\n  appendSequence!(rpc::RedPitayaCluster, value)\n\nAs with single RedPitaya, but applied to all RedPitayas in a cluster.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.prepareSequence!","page":"Client","title":"RedPitayaDAQServer.prepareSequence!","text":"prepareSequence!(rp::RedPitaya)\n\nInstruct the server to prepare the currently added sequences. Returns true if server could prepare, false otherwise.\n\n\n\n\n\nprepareSequence!(rpc::RedPitayaCluster)\n\nAs with single RedPitaya, but applied to all RedPitayas in a cluster. Returns true if all could servers could prepare, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.clearSequences!","page":"Client","title":"RedPitayaDAQServer.clearSequences!","text":"clearSequences!(rp::RedPitaya)\n\nInstruct the server to remove all sequences from its list.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.popSequence!","page":"Client","title":"RedPitayaDAQServer.popSequence!","text":"popSequence!(rp::RedPitaya)\n\nInstruct the server to remove the last added sequence from its list.\n\n\n\n\n\n","category":"function"},{"location":"client.html#Base.length-Tuple{AbstractSequence}","page":"Client","title":"Base.length","text":"length(seq::AbstractSequence)\n\nReturn the number of steps a sequence will take.\n\n\n\n\n\n","category":"method"},{"location":"client.html#RedPitayaDAQServer.start","page":"Client","title":"RedPitayaDAQServer.start","text":"start(seq::AbstractSequence)\n\nReturn the number of steps after which a sequence leaves the ramp up phase.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.ArbitrarySequence","page":"Client","title":"RedPitayaDAQServer.ArbitrarySequence","text":"ArbitrarySequence <: AbstractSequence\n\nStruct representing a sequence in which the server directly takes the values from the given LUT.\n\n\n\n\n\n","category":"type"},{"location":"client.html#RedPitayaDAQServer.ArbitrarySequence-NTuple{8,Any}","page":"Client","title":"RedPitayaDAQServer.ArbitrarySequence","text":"ArbitrarySequence(lut, enable, stepsPerRepetition, repetitions, upSteps, upTotalSteps, downSteps, rampDownTotalSteps, reset=false)\n\nConstructor for ArbitrarySequence.\n\nArguments\n\nlut::Array{Float32}: nxm matrix containing m steps for n channel\nemable::Union{Array{Bool}, Nothing}: matrix containing enable flags\nrepetitions::Int32: the number of times the sequence should be repeated\nupSteps::Int32: the number of steps the ramping factor should be increasing to 1.0\nupTotalSteps::Int32: the total number of steps spent in the ramp up phase\ndownSteps::Int32 the number of steps the ramping factor should be decreasing to 0.0\ndownTotalSteps::Int32: the total number of steps spent in the ramp down phase\nreset::Bool: flag if the phase should be reset after this sequence is done\n\n\n\n\n\n","category":"method"},{"location":"client.html#Measurement-and-Transmission","page":"Client","title":"Measurement and Transmission","text":"","category":"section"},{"location":"client.html","page":"Client","title":"Client","text":"RedPitayaDAQServer.ServerMode\nRedPitayaDAQServer.serverMode\nRedPitayaDAQServer.serverMode!\nRedPitayaDAQServer.masterTrigger\nRedPitayaDAQServer.masterTrigger!\nRedPitayaDAQServer.currentWP\nRedPitayaDAQServer.currentFrame\nRedPitayaDAQServer.currentPeriod\nRedPitayaDAQServer.SampleChunk\nRedPitayaDAQServer.PerformanceData\nRedPitayaDAQServer.readPipelinedSamples\nRedPitayaDAQServer.readFrames\nRedPitayaDAQServer.convertSamplesToFrames\nRedPitayaDAQServer.calibDACOffset\nRedPitayaDAQServer.calibDACOffset!\nRedPitayaDAQServer.calibADCOffset\nRedPitayaDAQServer.calibADCOffset!\nRedPitayaDAQServer.calibADCScale\nRedPitayaDAQServer.calibADCScale!","category":"page"},{"location":"client.html#RedPitayaDAQServer.ServerMode","page":"Client","title":"RedPitayaDAQServer.ServerMode","text":"ServerMode\n\nRepresent the different modes the server can be in.\n\nSee also serverMode, serverMode!.\n\n\n\n\n\n","category":"type"},{"location":"client.html#RedPitayaDAQServer.serverMode","page":"Client","title":"RedPitayaDAQServer.serverMode","text":"serverMode(rp::RedPitaya)\n\nReturn the mode of the server.\n\nExamples\n\njulia> serverMode!(rp, MEASUREMENT);\n\njulia> serverMode(rp)\nMEASUREMENT\n\n\n\n\n\nserverMode(rpc::RedPitayaCluster)\n\nAs with single RedPitaya, but applied to only the master.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.serverMode!","page":"Client","title":"RedPitayaDAQServer.serverMode!","text":"serverMode!(rp::RedPitaya, mode::ServerMode)\n\nSet the mode of the server. Valid values are \"CONFIGURATION\" and \"MEASUREMENT\".\n\nExamples\n\njulia> serverMode!(rp, MEASUREMENT);\n\njulia> serverMode(rp)\nMEASUREMENT\n\n\n\n\n\nserverMode!(rp::RedPitaya, mode::ServerMode)\n\nSet the mode of the server.\n\nExamples\n\njulia> serverMode!(rp, MEASUREMENT);\n\njulia> serverMode(rp)\nMEASUREMENT\n\n\n\n\n\n  serverMode!(rpc::RedPitayaCluster, value)\n\nAs with single RedPitaya, but applied to all RedPitayas in a cluster.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.masterTrigger","page":"Client","title":"RedPitayaDAQServer.masterTrigger","text":"masterTrigger(rp::RedPitaya)\n\nDetermine whether the master trigger is set.\n\nExample\n\njulia> masterTrigger!(rp, true)\n\njulia>masterTrigger(rp)\ntrue\n\n\n\n\n\nmasterTrigger(rpc::RedPitayaCluster)\n\nAs with single RedPitaya, but applied to only the master.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.masterTrigger!","page":"Client","title":"RedPitayaDAQServer.masterTrigger!","text":"masterTrigger!(rp::RedPitaya, val::Bool)\n\nSet the master trigger of the RedPitaya to val.\n\nExample\n\njulia> masterTrigger!(rp, true)\n\njulia>masterTrigger(rp)\ntrue\n\n\n\n\n\nmasterTrigger(rpc::RedPitayaCluster, val::Bool)\n\nSet the master trigger of the cluster to val. \n\nFor val equals to true this is the same as calling the function on the RedPitaya returned by master(rpc). If val is false then the keepAliveReset is set to true for all RedPitayas in the cluster before the master trigger is disabled. Afterwards the keepAliveReset is set to false again.\n\nSee also master, keepAliveReset!.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.currentWP","page":"Client","title":"RedPitayaDAQServer.currentWP","text":"currentWP(rp::RedPitaya)\n\nReturn the current writepointer of the RedPitaya.\n\n\n\n\n\ncurrentWP(rpc::RedPitayaCluster)\n\nAs with single RedPitaya, but applied to only the master.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.currentFrame","page":"Client","title":"RedPitayaDAQServer.currentFrame","text":"currentFrame(rp::RedPitaya)\n\nReturn the current frame of the RedPitaya based on the current writepointer, samples per period and periods per frame.\n\nSee also currentWP, samplesPerPeriod, periodsPerFrame.\n\n\n\n\n\ncurrentFrame(rpc::RedPitayaCluster)\n\nAs with single RedPitaya, but applied to only the master.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.currentPeriod","page":"Client","title":"RedPitayaDAQServer.currentPeriod","text":"currentPeriod(rp::RedPitaya)\n\nReturn the current period of the RedPitaya based on the current writepointer and samples per period.\n\nSee also currentWP, samplesPerPeriod.\n\n\n\n\n\ncurrentPeriod(rpc::RedPitayaCluster)\n\nAs with single RedPitaya, but applied to only the master.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.SampleChunk","page":"Client","title":"RedPitayaDAQServer.SampleChunk","text":"SampleChunk\n\nStruct containing a matrix of samples and associated PerformanceData\n\nFields\n\nsamples::Matrix{Int16}: nxm matrix containing m samples for n channel\nperformance::Vector{PerformanceData}: PerformanceData object for each RedPitaya that transmitted samples\n\n\n\n\n\n","category":"type"},{"location":"client.html#RedPitayaDAQServer.readPipelinedSamples","page":"Client","title":"RedPitayaDAQServer.readPipelinedSamples","text":"readPipelinedSamples(rpu::Union{RedPitaya,RedPitayaCluster, RedPitayaClusterView}, wpStart::Int64, numOfRequestedSamples::Int64; chunkSize::Int64 = 25000, rpInfo=nothing)\n\nRequest and receive numOfRequestedSamples samples from wpStart on in a pipelined fashion. Return a matrix of samples.\n\nIf rpInfo is set to a RPInfo, the PerformanceData sent after every chunkSize samples will be pushed into rpInfo.\n\n\n\n\n\nreadPipelinedSamples(rpu::Union{RedPitaya,RedPitayaCluster, RedPitayaClusterView}, wpStart::Int64, numOfRequestedSamples::Int64, channel::Channel; chunkSize::Int64 = 25000)\n\nRequest and receive numOfRequestedSamples samples from wpStart on in a pipelined fashion. The samples and associated PerformanceData are pushed into channel as a SampleChunk.\n\nSee SampleChunk.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.readFrames","page":"Client","title":"RedPitayaDAQServer.readFrames","text":"readFrames(rpu::Union{RedPitaya,RedPitayaCluster, RedPitayaClusterView}, startFrame, numFrames, numBlockAverages=1, numPeriodsPerPatch=1; rpInfo=nothing, chunkSize = 50000, useCalibration = false)\n\nRequest and receive numFrames frames from startFrame on.\n\nSee readPipelinedSamples, convertSamplesToFrames, samplesPerPeriod, periodsPerFrame, updateCalib!.\n\nArguments\n\nrpu::Union{RedPitaya,RedPitayaCluster, RedPitayaClusterView}: RedPitayas to receive samples from.\nstartFrame: frame from which to start transmitting\nnumFrames: number of frames to read\nnumBlockAverages=1: see convertSamplesToFrames\nnumPeriodsPerPatch=1: see convertSamplesToFrames\nchunkSize=50000: see readPipelinedSamples\nrpInfo=nothing: see readPipelinedSamples\nuseCalibration: convert from Int16 samples to Float32 values based on RedPitayas calibration\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.calibDACOffset","page":"Client","title":"RedPitayaDAQServer.calibDACOffset","text":"calibDACOffset(rp::RedPitaya, channel::Integer)\n\nRetrieve the calibration DAC offset for given channel from the RedPitayas EEPROM \n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.calibDACOffset!","page":"Client","title":"RedPitayaDAQServer.calibDACOffset!","text":"calibDACOffset!(rp::RedPitaya, channel::Integer, val)\n\nStore calibration DAC offset val for given channel into the RedPitayas EEPROM.  This value is used by the server to offset the output voltage. Absolute value has to be smaller than 1.0 V. \n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.calibADCOffset","page":"Client","title":"RedPitayaDAQServer.calibADCOffset","text":"calibADCOffset(rp::RedPitaya, channel::Integer)\n\nRetrieve the calibration ADC offset for given channel from the RedPitayas EEPROM.\n\nSee also convertSamplesToPeriods,convertSamplesToFrames.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.calibADCOffset!","page":"Client","title":"RedPitayaDAQServer.calibADCOffset!","text":"calibADCOffset!(rp::RedPitaya, channel::Integer, val)\n\nStore calibration ADC offset val for given channel into the RedPitayas EEPROM. Absolute value has to be smaller than 1.0 V.\n\nSee also convertSamplesToPeriods,convertSamplesToFrames.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.calibADCScale","page":"Client","title":"RedPitayaDAQServer.calibADCScale","text":"calibADCScale(rp::RedPitaya, channel::Integer)\n\nRetrieve the calibration ADC scale for given channel from the RedPitayas EEPROM.\n\nSee also convertSamplesToPeriods,convertSamplesToFrames.\n\n\n\n\n\n","category":"function"},{"location":"client.html#RedPitayaDAQServer.calibADCScale!","page":"Client","title":"RedPitayaDAQServer.calibADCScale!","text":"calibADCScale(rp::RedPitaya, channel::Integer)\n\nStore calibration ADC scale val for given channel into the RedPitayas EEPROM. Absolute value has to be smaller than 1.0 V.\n\nSee also convertSamplesToPeriods,convertSamplesToFrames.\n\n\n\n\n\n","category":"function"},{"location":"scpi.html#SCPI-Interface","page":"SCPI Interface","title":"SCPI Interface","text":"","category":"section"},{"location":"scpi.html","page":"SCPI Interface","title":"SCPI Interface","text":"For communication betten the server and the client an SCPI with custom commands is used. The following table gives an overview of all commands:","category":"page"},{"location":"scpi.html#DIO","page":"SCPI Interface","title":"DIO","text":"","category":"section"},{"location":"scpi.html","page":"SCPI Interface","title":"SCPI Interface","text":"Command Arguments Description Example\nRP:DIO:DIR identifier of pin, direction (IN/OUT) Set the direction of the DIO RP:DIO:DIR DIO7_P,IN\nRP:DIO identifier of pin, value (0/1) Set the output of the DIO RP:DIO DIO7_P,1\nRP:DIO? identifier of pin Get the input of the DIO RP:DIO? DIO7_P","category":"page"},{"location":"scpi.html#Fast-ADC","page":"SCPI Interface","title":"Fast ADC","text":"","category":"section"},{"location":"scpi.html","page":"SCPI Interface","title":"SCPI Interface","text":"Command Arguments Description Example\nRP:ADC:SlowADC   \nRP:ADC:SlowADC?   \nRP:ADC:DECimation   \nRP:ADC:DECimation?   \nRP:ADC:WP:CURRent?   \nRP:ADC:BUFfer:Size?   \nRP:ADC:ACQCONNect   \nRP:ADC:ACQSTATus   \nRP:ADC:ACQSTATus?   \nRP:ADC:DATa?   \nRP:ADC:DATa:DETailed?   \nRP:ADC:DATa:PIPElined?   ","category":"page"},{"location":"scpi.html#DAC","page":"SCPI Interface","title":"DAC","text":"","category":"section"},{"location":"scpi.html","page":"SCPI Interface","title":"SCPI Interface","text":"Command Arguments Description Example\nRP:DAC:CHannel#:COMPonent#:AMPlitude?   \nRP:DAC:CHannel#:COMPonent#:AMPlitude   \nRP:DAC:CHannel#:COMPonent#:Next:AMPlitude?   \nRP:DAC:CHannel#:COMPonent#:Next:AMPlitude   \nRP:DAC:CHannel#:COMPonent#:FREQuency?   \nRP:DAC:CHannel#:COMPonent#:FREQuency   \nRP:DAC:CHannel#:COMPonent#:PHase?   \nRP:DAC:CHannel#:COMPonent#:PHase   \nRP:DAC:CHannel#:OFFset?   \nRP:DAC:CHannel#:OFFset   \nRP:DAC:MODe   \nRP:DAC:MODe?   \nRP:DAC:CHannel#:SIGnaltype signaltype (SINE / SQUARE / TRIANGLE / SAWTOOTH) set the signal type RP:DAC:CH0:SIG SINE\nRP:DAC:CHannel#:SIGnaltype?   \nRP:DAC:CHannel#:JumpSharpness   \nRP:DAC:CHannel#:JumpSharpness?   \nRP:ADC:SlowDAC   \nRP:ADC:SlowDAC?   \nRP:ADC:SlowDACLUT   \nRP:ADC:SlowDACEnable   \nRP:ADC:SlowDACLostSteps?   \nRP:ADC:SlowDACPeriodsPerFrame   \nRP:ADC:SlowDACPeriodsPerFrame?   \nRP:PDM:ClockDivider   \nRP:PDM:ClockDivider?   ","category":"page"},{"location":"scpi.html#Sequences","page":"SCPI Interface","title":"Sequences","text":"","category":"section"},{"location":"scpi.html","page":"SCPI Interface","title":"SCPI Interface","text":"Command Arguments Description Example\nRP:DAC:SEQ:CHan   \nRP:DAC:SEQ:CHan?   \nRP:DAC:SEQ:LUT:ARBITRARY   \nRP:DAC:SEQ:LUT:CONSTANT   \nRP:DAC:SEQ:LUT:PAUSE   \nRP:DAC:SEQ:LUT:RANGE   \nRP:DAC:SEQ:LUT:ENaBle   \nRP:DAC:SEQ:LostSteps?   \nRP:DAC:SEQ:STEPsPerSequence   \nRP:DAC:SEQ:STEPsPerSequence?   \nRP:DAC:SEQ:SAMPlesperstep   \nRP:DAC:SEQ:SAMPlesperstep?   \nRP:DAC:SEQ:RaMPing   \nRP:DAC:SEQ:RaMPing:STEPs   \nRP:DAC:SEQ:RaMPing:TOTAL   \nRP:DAC:SEQ:RaMPing:UP   \nRP:DAC:SEQ:RaMPing:UP:STEPs   \nRP:DAC:SEQ:RaMPing:UP:STEPs?   \nRP:DAC:SEQ:RaMPing:UP:TOTAL   \nRP:DAC:SEQ:RaMPing:UP:TOTAL?   \nRP:DAC:SEQ:RaMPing:DOWN   \nRP:DAC:SEQ:RaMPing:DOWN:STEPs   \nRP:DAC:SEQ:RaMPing:DOWN:STEPs?   \nRP:DAC:SEQ:RaMPing:DOWN:TOTAL   \nRP:DAC:SEQ:RaMPing:DOWN:TOTAL?   \nRP:DAC:SEQ:REPetitions   \nRP:DAC:SEQ:REPetitions?   \nRP:DAC:SEQ:RESETafter   \nRP:DAC:SEQ:RESETafter?   \nRP:DAC:SEQ:APPend   \nRP:DAC:SEQ:POP   \nRP:DAC:SEQ:CLEAR   \nRP:DAC:SEQ:PREPare?   ","category":"page"},{"location":"scpi.html#Misc","page":"SCPI Interface","title":"Misc","text":"","category":"section"},{"location":"scpi.html","page":"SCPI Interface","title":"SCPI Interface","text":"Command Arguments Description Example\nRP:XADC:CHannel#?   \nRP:WatchDogMode   \nRP:WatchDogMode?   \nRP:RamWriterMode   \nRP:RamWriterMode?   \nRP:PassPDMToFastDAC   \nRP:PassPDMToFastDAC?   \nRP:KeepAliveReset   \nRP:KeepAliveReset?   \nRP:Trigger:MODe   \nRP:Trigger:MODe?   \nRP:MasterTrigger   \nRP:InstantResetMode   \nRP:InstantResetMode?   \nRP:PeripheralAResetN?   \nRP:FourierSynthAResetN?   \nRP:PDMAResetN?   \nRP:XADCAResetN?   \nRP:TriggerStatus?   \nRP:WatchdogStatus?   \nRP:InstantResetStatus?   ","category":"page"},{"location":"devtips.html#Development-Tips","page":"Development Tips","title":"Development Tips","text":"","category":"section"},{"location":"devtips.html","page":"Development Tips","title":"Development Tips","text":"On this slide some development hints are summarized. These might change regularely if things are properly integrated into the framework.","category":"page"},{"location":"devtips.html#Alpine-Linux","page":"Development Tips","title":"Alpine Linux","text":"","category":"section"},{"location":"devtips.html","page":"Development Tips","title":"Development Tips","text":"The Alpine linux as currently a root folder with only 185.8M free space, which disallows installing more","category":"page"},{"location":"devtips.html","page":"Development Tips","title":"Development Tips","text":"applications. To change this one can do","category":"page"},{"location":"devtips.html","page":"Development Tips","title":"Development Tips","text":"mount -o remount,size=1G /","category":"page"},{"location":"devtips.html","page":"Development Tips","title":"Development Tips","text":"Right now no debugger is installed. This can be change after increasing / using:","category":"page"},{"location":"devtips.html","page":"Development Tips","title":"Development Tips","text":"apk add gdb","category":"page"},{"location":"devtips.html#DHCP-Server","page":"Development Tips","title":"DHCP Server","text":"","category":"section"},{"location":"devtips.html","page":"Development Tips","title":"Development Tips","text":"One possible configuration to run single or a cluster of RedPitayas is to directly connect them with the measurement computer. In case of a cluster one can use a switch such that only a single network connector is required. In case that the measurement computer has no free ethernet port one can use a USB network adapter.","category":"page"},{"location":"devtips.html","page":"Development Tips","title":"Development Tips","text":"In order to get this setup running you need to install a dhcp server and give the measurement computer a static IP address (e.g. 192.168.1.1). Then you can configure the dhcp server by modifying the configuration file /etc/dhcp/dhcpd.conf where you should create a network with a certain range (e.g. 192.168.1.100-105). You also have the opportunity to map a certain RedPitaya to a certain IP address by specifying the MAC address. You may also need to specify DNS servers.","category":"page"},{"location":"devtips.html","page":"Development Tips","title":"Development Tips","text":"The following commands are useful when you have connection problems","category":"page"},{"location":"devtips.html","page":"Development Tips","title":"Development Tips","text":"nmap -sP 192.168.1.0/24 \njournalctl -f -u isc-dhcp-server","category":"page"},{"location":"devtips.html","page":"Development Tips","title":"Development Tips","text":"If you need internet at your RedPitaya you need to configure the firewall to allow this using iptables. In this repository there is in the scripts directory a script rp-internet.sh where you need to change the network adapters to allow traffic going from the internet network adapter to the RedPitaya network adapter.","category":"page"},{"location":"index.html#RedPitayaDAQServer","page":"Home","title":"RedPitayaDAQServer","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Advanced DAQ Tools for the RedPitaya (STEMlab 125-14)","category":"page"},{"location":"index.html#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This project contains software to be used with the STEMlab 125-14 device from RedPitaya. It allows for continuous generation and measurement of signals with up to 15.625 MS/s, which is not possible with the standard image of the RedPitaya. In addition, the software allows to synchronize a cluster of multiple RedPitayas. This project contains the following parts:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Alpine Linux image for the RedPitaya\nFPGA image\nClient library (implemented in C) that can be used on the RedPitaya\nSCPI Server for accessing the functionality over TCP/IP\nSCPI Client to access the server","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The code repositories is contained in this repository.","category":"page"},{"location":"index.html#License-/-Terms-of-Usage","page":"Home","title":"License / Terms of Usage","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The source code of this project is licensed under the MIT license. This implies that you are free to use, share, and adapt it. However, please give appropriate credit by citing the project.","category":"page"},{"location":"index.html#Contact","page":"Home","title":"Contact","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"If you have problems using the software, find mistakes, or have general questions please use the issue tracker to contact us.","category":"page"},{"location":"index.html#Contributors","page":"Home","title":"Contributors","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Tobias Knopp\nNiklas Hackelberg\nJonas Schumacher\nMatthias Grser","category":"page"},{"location":"index.html#Credit","page":"Home","title":"Credit","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This package is partly based on work of Koheron [1] and Pavel Demin [2]","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"[1] https://www.koheron.com/blog/2016/11/29/red-pitaya-cluster [2] https://github.com/pavel-demin/red-pitaya-notes","category":"page"}]
}
